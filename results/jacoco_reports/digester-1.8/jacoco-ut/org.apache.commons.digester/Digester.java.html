<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Digester.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Digester</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.digester</a> &gt; <span class="el_source">Digester.java</span></div><h1>Digester.java</h1><pre class="source lang-java linenums">/* $Id$
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ 

package org.apache.commons.digester;


import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.collections.ArrayStack;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;




/**
 * &lt;p&gt;A &lt;strong&gt;Digester&lt;/strong&gt; processes an XML input stream by matching a
 * series of element nesting patterns to execute Rules that have been added
 * prior to the start of parsing.  This package was inspired by the
 * &lt;code&gt;XmlMapper&lt;/code&gt; class that was part of Tomcat 3.0 and 3.1,
 * but is organized somewhat differently.&lt;/p&gt;
 *
 * &lt;p&gt;See the &lt;a href=&quot;package-summary.html#package_description&quot;&gt;Digester
 * Developer Guide&lt;/a&gt; for more information.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - A single Digester instance may
 * only be used within the context of a single thread at a time, and a call
 * to &lt;code&gt;parse()&lt;/code&gt; must be completed before another can be initiated
 * even from the same thread.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - A bug in Xerces 2.0.2 prevents
 * the support of XML schema. You need Xerces 2.1/2.3 and up to make
 * this class working with XML schema&lt;/p&gt;
 */

public class Digester extends DefaultHandler {


    // --------------------------------------------------------- Constructors


    /**
     * Construct a new Digester with default properties.
     */
    public Digester() {

<span class="fc" id="L94">        super();</span>

<span class="fc" id="L96">    }</span>


    /**
     * Construct a new Digester, allowing a SAXParser to be passed in.  This
     * allows Digester to be used in environments which are unfriendly to
     * JAXP1.1 (such as WebLogic 6.0). This may help in places where
     * you are able to load JAXP 1.1 classes yourself.
     */
    public Digester(SAXParser parser) {

<span class="nc" id="L107">        super();</span>

<span class="nc" id="L109">        this.parser = parser;</span>

<span class="nc" id="L111">    }</span>


    /**
     * Construct a new Digester, allowing an XMLReader to be passed in.  This
     * allows Digester to be used in environments which are unfriendly to
     * JAXP1.1 (such as WebLogic 6.0).  Note that if you use this option you
     * have to configure namespace and validation support yourself, as these
     * properties only affect the SAXParser and emtpy constructor.
     */
    public Digester(XMLReader reader) {

<span class="nc" id="L123">        super();</span>

<span class="nc" id="L125">        this.reader = reader;</span>

<span class="nc" id="L127">    }</span>


    // --------------------------------------------------- Instance Variables


    /**
     * The body text of the current element.
     */
<span class="pc" id="L136">    protected StringBuffer bodyText = new StringBuffer();</span>


    /**
     * The stack of body text string buffers for surrounding elements.
     */
<span class="pc" id="L142">    protected ArrayStack bodyTexts = new ArrayStack();</span>


    /**
     * Stack whose elements are List objects, each containing a list of
     * Rule objects as returned from Rules.getMatch(). As each xml element
     * in the input is entered, the matching rules are pushed onto this
     * stack. After the end tag is reached, the matches are popped again.
     * The depth of is stack is therefore exactly the same as the current
     * &quot;nesting&quot; level of the input xml. 
     *
     * @since 1.6
     */
<span class="pc" id="L155">    protected ArrayStack matches = new ArrayStack(10);</span>
    
    /**
     * The class loader to use for instantiating application objects.
     * If not specified, the context class loader, or the class loader
     * used to load Digester itself, is used, based on the value of the
     * &lt;code&gt;useContextClassLoader&lt;/code&gt; variable.
     */
<span class="pc" id="L163">    protected ClassLoader classLoader = null;</span>


    /**
     * Has this Digester been configured yet.
     */
<span class="pc" id="L169">    protected boolean configured = false;</span>


    /**
     * The EntityResolver used by the SAX parser. By default it use this class
     */
    protected EntityResolver entityResolver;
    
    /**
     * The URLs of entityValidator that have been registered, keyed by the public
     * identifier that corresponds.
     */
<span class="pc" id="L181">    protected HashMap entityValidator = new HashMap();</span>


    /**
     * The application-supplied error handler that is notified when parsing
     * warnings, errors, or fatal errors occur.
     */
<span class="pc" id="L188">    protected ErrorHandler errorHandler = null;</span>


    /**
     * The SAXParserFactory that is created the first time we need it.
     */
<span class="pc" id="L194">    protected SAXParserFactory factory = null;</span>

    /**
     * @deprecated This is now managed by {@link ParserFeatureSetterFactory}
     */
<span class="pc" id="L199">    protected String JAXP_SCHEMA_LANGUAGE =</span>
        &quot;http://java.sun.com/xml/jaxp/properties/schemaLanguage&quot;;
    
    
    /**
     * The Locator associated with our parser.
     */
<span class="pc" id="L206">    protected Locator locator = null;</span>


    /**
     * The current match pattern for nested element processing.
     */
<span class="pc" id="L212">    protected String match = &quot;&quot;;</span>


    /**
     * Do we want a &quot;namespace aware&quot; parser.
     */
<span class="pc" id="L218">    protected boolean namespaceAware = false;</span>


    /**
     * Registered namespaces we are currently processing.  The key is the
     * namespace prefix that was declared in the document.  The value is an
     * ArrayStack of the namespace URIs this prefix has been mapped to --
     * the top Stack element is the most current one.  (This architecture
     * is required because documents can declare nested uses of the same
     * prefix for different Namespace URIs).
     */
<span class="pc" id="L229">    protected HashMap namespaces = new HashMap();</span>


    /**
     * The parameters stack being utilized by CallMethodRule and
     * CallParamRule rules.
     */
<span class="pc" id="L236">    protected ArrayStack params = new ArrayStack();</span>


    /**
     * The SAXParser we will use to parse the input stream.
     */
<span class="pc" id="L242">    protected SAXParser parser = null;</span>


    /**
     * The public identifier of the DTD we are currently parsing under
     * (if any).
     */
<span class="pc" id="L249">    protected String publicId = null;</span>


    /**
     * The XMLReader used to parse digester rules.
     */
<span class="pc" id="L255">    protected XMLReader reader = null;</span>


    /**
     * The &quot;root&quot; element of the stack (in other words, the last object
     * that was popped.
     */
<span class="pc" id="L262">    protected Object root = null;</span>


    /**
     * The &lt;code&gt;Rules&lt;/code&gt; implementation containing our collection of
     * &lt;code&gt;Rule&lt;/code&gt; instances and associated matching policy.  If not
     * established before the first rule is added, a default implementation
     * will be provided.
     */
<span class="pc" id="L271">    protected Rules rules = null;</span>

   /**
     * The XML schema language to use for validating an XML instance. By
     * default this value is set to &lt;code&gt;W3C_XML_SCHEMA&lt;/code&gt;
     */
<span class="pc" id="L277">    protected String schemaLanguage = W3C_XML_SCHEMA;</span>
    
        
    /**
     * The XML schema to use for validating an XML instance.
     */
<span class="pc" id="L283">    protected String schemaLocation = null;</span>
    
    
    /**
     * The object stack being constructed.
     */
<span class="pc" id="L289">    protected ArrayStack stack = new ArrayStack();</span>


    /**
     * Do we want to use the Context ClassLoader when loading classes
     * for instantiating new objects.  Default is &lt;code&gt;false&lt;/code&gt;.
     */
<span class="pc" id="L296">    protected boolean useContextClassLoader = false;</span>


    /**
     * Do we want to use a validating parser.
     */
<span class="pc" id="L302">    protected boolean validating = false;</span>


    /**
     * The Log to which most logging calls will be made.
     */
<span class="pc" id="L308">    protected Log log =</span>
<span class="pc" id="L309">        LogFactory.getLog(&quot;org.apache.commons.digester.Digester&quot;);</span>


    /**
     * The Log to which all SAX event related logging calls will be made.
     */
<span class="pc" id="L315">    protected Log saxLog =</span>
<span class="pc" id="L316">        LogFactory.getLog(&quot;org.apache.commons.digester.Digester.sax&quot;);</span>
    
        
    /**
     * The schema language supported. By default, we use this one.
     */
    protected static final String W3C_XML_SCHEMA =
        &quot;http://www.w3.org/2001/XMLSchema&quot;;
    
    /**
     * An optional class that substitutes values in attributes and body text.
     * This may be null and so a null check is always required before use.
     */
    protected Substitutor substitutor;
    
    /** Stacks used for interrule communication, indexed by name String */
<span class="pc" id="L332">    private HashMap stacksByName = new HashMap();</span>
    
    /**
     * If not null, then calls by the parser to this object's characters, 
     * startElement, endElement and processingInstruction methods are 
     * forwarded to the specified object. This is intended to allow rules
     * to temporarily &quot;take control&quot; of the sax events. In particular, 
     * this is used by NodeCreateRule.
     * &lt;p&gt;
     * See setCustomContentHandler.
     */
<span class="pc" id="L343">    private ContentHandler customContentHandler = null;</span>

    /**
     * Object which will receive callbacks for every pop/push action
     * on the default stack or named stacks. 
     */
<span class="pc" id="L349">    private StackAction stackAction = null;</span>

    // ------------------------------------------------------------- Properties

    /**
     * Return the currently mapped namespace URI for the specified prefix,
     * if any; otherwise return &lt;code&gt;null&lt;/code&gt;.  These mappings come and
     * go dynamically as the document is parsed.
     *
     * @param prefix Prefix to look up
     */
    public String findNamespaceURI(String prefix) {
        
<span class="nc" id="L362">        ArrayStack nsStack = (ArrayStack) namespaces.get(prefix);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (nsStack == null) {</span>
<span class="nc" id="L364">            return null;</span>
        }
        try {
<span class="nc" id="L367">            return ((String) nsStack.peek());</span>
<span class="nc" id="L368">        } catch (EmptyStackException e) {</span>
<span class="nc" id="L369">            return null;</span>
        }

    }


    /**
     * Return the class loader to be used for instantiating application objects
     * when required.  This is determined based upon the following rules:
     * &lt;ul&gt;
     * &lt;li&gt;The class loader set by &lt;code&gt;setClassLoader()&lt;/code&gt;, if any&lt;/li&gt;
     * &lt;li&gt;The thread context class loader, if it exists and the
     *     &lt;code&gt;useContextClassLoader&lt;/code&gt; property is set to true&lt;/li&gt;
     * &lt;li&gt;The class loader used to load the Digester class itself.
     * &lt;/ul&gt;
     */
    public ClassLoader getClassLoader() {

<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (this.classLoader != null) {</span>
<span class="fc" id="L388">            return (this.classLoader);</span>
        }
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (this.useContextClassLoader) {</span>
            ClassLoader classLoader =
<span class="nc" id="L392">                    Thread.currentThread().getContextClassLoader();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (classLoader != null) {</span>
<span class="nc" id="L394">                return (classLoader);</span>
            }
        }
<span class="fc" id="L397">        return (this.getClass().getClassLoader());</span>

    }


    /**
     * Set the class loader to be used for instantiating application objects
     * when required.
     *
     * @param classLoader The new class loader to use, or &lt;code&gt;null&lt;/code&gt;
     *  to revert to the standard rules
     */
    public void setClassLoader(ClassLoader classLoader) {

<span class="fc" id="L411">        this.classLoader = classLoader;</span>

<span class="fc" id="L413">    }</span>


    /**
     * Return the current depth of the element stack.
     */
    public int getCount() {

<span class="fc" id="L421">        return (stack.size());</span>

    }


    /**
     * Return the name of the XML element that is currently being processed.
     */
    public String getCurrentElementName() {

<span class="nc" id="L431">        String elementName = match;</span>
<span class="nc" id="L432">        int lastSlash = elementName.lastIndexOf('/');</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (lastSlash &gt;= 0) {</span>
<span class="nc" id="L434">            elementName = elementName.substring(lastSlash + 1);</span>
        }
<span class="nc" id="L436">        return (elementName);</span>

    }


    /**
     * Return the debugging detail level of our currently enabled logger.
     *
     * @deprecated This method now always returns 0. Digester uses the apache
     * jakarta commons-logging library; see the documentation for that library
     * for more information.
     */
    public int getDebug() {

<span class="nc" id="L450">        return (0);</span>

    }


    /**
     * Set the debugging detail level of our currently enabled logger.
     *
     * @param debug New debugging detail level (0=off, increasing integers
     *  for more detail)
     *
     * @deprecated This method now has no effect at all. Digester uses
     * the apache jakarta comons-logging library; see the documentation
     * for that library for more information.
     */
    public void setDebug(int debug) {

        ; // No action is taken

<span class="nc" id="L469">    }</span>


    /**
     * Return the error handler for this Digester.
     */
    public ErrorHandler getErrorHandler() {

<span class="fc" id="L477">        return (this.errorHandler);</span>

    }


    /**
     * Set the error handler for this Digester.
     *
     * @param errorHandler The new error handler
     */
    public void setErrorHandler(ErrorHandler errorHandler) {

<span class="fc" id="L489">        this.errorHandler = errorHandler;</span>

<span class="fc" id="L491">    }</span>


    /**
     * Return the SAXParserFactory we will use, creating one if necessary.
     */
    public SAXParserFactory getFactory() {

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (factory == null) {</span>
<span class="fc" id="L500">            factory = SAXParserFactory.newInstance();</span>
<span class="fc" id="L501">            factory.setNamespaceAware(namespaceAware);</span>
<span class="fc" id="L502">            factory.setValidating(validating);</span>
        }
<span class="fc" id="L504">        return (factory);</span>

    }


    /**
     * Returns a flag indicating whether the requested feature is supported
     * by the underlying implementation of &lt;code&gt;org.xml.sax.XMLReader&lt;/code&gt;.
     * See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt;
     * for information about the standard SAX2 feature flags.
     *
     * @param feature Name of the feature to inquire about
     *
     * @exception ParserConfigurationException if a parser configuration error
     *  occurs
     * @exception SAXNotRecognizedException if the property name is
     *  not recognized
     * @exception SAXNotSupportedException if the property name is
     *  recognized but not supported
     */
    public boolean getFeature(String feature)
        throws ParserConfigurationException, SAXNotRecognizedException,
        SAXNotSupportedException {

<span class="nc" id="L528">        return (getFactory().getFeature(feature));</span>

    }


    /**
     * Sets a flag indicating whether the requested feature is supported
     * by the underlying implementation of &lt;code&gt;org.xml.sax.XMLReader&lt;/code&gt;.
     * See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt;
     * for information about the standard SAX2 feature flags.  In order to be
     * effective, this method must be called &lt;strong&gt;before&lt;/strong&gt; the
     * &lt;code&gt;getParser()&lt;/code&gt; method is called for the first time, either
     * directly or indirectly.
     *
     * @param feature Name of the feature to set the status for
     * @param value The new value for this feature
     *
     * @exception ParserConfigurationException if a parser configuration error
     *  occurs
     * @exception SAXNotRecognizedException if the property name is
     *  not recognized
     * @exception SAXNotSupportedException if the property name is
     *  recognized but not supported
     */
    public void setFeature(String feature, boolean value)
        throws ParserConfigurationException, SAXNotRecognizedException,
        SAXNotSupportedException {

<span class="nc" id="L556">        getFactory().setFeature(feature, value);</span>

<span class="nc" id="L558">    }</span>


    /**
     * Return the current Logger associated with this instance of the Digester
     */
    public Log getLogger() {

<span class="fc" id="L566">        return log;</span>

    }


    /**
     * Set the current logger for this Digester.
     */
    public void setLogger(Log log) {

<span class="fc" id="L576">        this.log = log;</span>

<span class="fc" id="L578">    }</span>

    /**
     * Gets the logger used for logging SAX-related information.
     * &lt;strong&gt;Note&lt;/strong&gt; the output is finely grained.
     *
     * @since 1.6
     */
    public Log getSAXLogger() {
        
<span class="nc" id="L588">        return saxLog;</span>
    }
    

    /**
     * Sets the logger used for logging SAX-related information.
     * &lt;strong&gt;Note&lt;/strong&gt; the output is finely grained.
     * @param saxLog Log, not null
     *
     * @since 1.6
     */    
    public void setSAXLogger(Log saxLog) {
    
<span class="nc" id="L601">        this.saxLog = saxLog;</span>
<span class="nc" id="L602">    }</span>

    /**
     * Return the current rule match path
     */
    public String getMatch() {

<span class="fc" id="L609">        return match;</span>

    }


    /**
     * Return the &quot;namespace aware&quot; flag for parsers we create.
     */
    public boolean getNamespaceAware() {

<span class="fc" id="L619">        return (this.namespaceAware);</span>

    }


    /**
     * Set the &quot;namespace aware&quot; flag for parsers we create.
     *
     * @param namespaceAware The new &quot;namespace aware&quot; flag
     */
    public void setNamespaceAware(boolean namespaceAware) {

<span class="fc" id="L631">        this.namespaceAware = namespaceAware;</span>

<span class="fc" id="L633">    }</span>

    
    /**
     * Set the publid id of the current file being parse.
     * @param publicId the DTD/Schema public's id.
     */
    public void setPublicId(String publicId){
<span class="nc" id="L641">        this.publicId = publicId;</span>
<span class="nc" id="L642">    }</span>
    
    
    /**
     * Return the public identifier of the DTD we are currently
     * parsing under, if any.
     */
    public String getPublicId() {

<span class="nc" id="L651">        return (this.publicId);</span>

    }


    /**
     * Return the namespace URI that will be applied to all subsequently
     * added &lt;code&gt;Rule&lt;/code&gt; objects.
     */
    public String getRuleNamespaceURI() {

<span class="fc" id="L662">        return (getRules().getNamespaceURI());</span>

    }


    /**
     * Set the namespace URI that will be applied to all subsequently
     * added &lt;code&gt;Rule&lt;/code&gt; objects.
     *
     * @param ruleNamespaceURI Namespace URI that must match on all
     *  subsequently added rules, or &lt;code&gt;null&lt;/code&gt; for matching
     *  regardless of the current namespace URI
     */
    public void setRuleNamespaceURI(String ruleNamespaceURI) {

<span class="fc" id="L677">        getRules().setNamespaceURI(ruleNamespaceURI);</span>

<span class="fc" id="L679">    }</span>


    /**
     * Return the SAXParser we will use to parse the input stream.  If there
     * is a problem creating the parser, return &lt;code&gt;null&lt;/code&gt;.
     */
    public SAXParser getParser() {

        // Return the parser we already created (if any)
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        if (parser != null) {</span>
<span class="nc" id="L690">            return (parser);</span>
        }

        // Create a new parser
        try {
<span class="pc bpc" id="L695" title="1 of 4 branches missed.">            if (validating &amp;&amp; (schemaLocation != null)) {</span>
                // There is no portable way to specify the location of
                // an xml schema to be applied to the input document, so
                // we have to use parser-specific code for this. That code
                // is hidden behind the ParserFeatureSetterFactory class.

<span class="nc" id="L701">                Properties properties = new Properties();</span>
<span class="nc" id="L702">                properties.put(&quot;SAXParserFactory&quot;, getFactory());</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                if (schemaLocation != null) {</span>
<span class="nc" id="L704">                    properties.put(&quot;schemaLocation&quot;, schemaLocation);</span>
<span class="nc" id="L705">                    properties.put(&quot;schemaLanguage&quot;, schemaLanguage);</span>
                }
<span class="nc" id="L707">                parser = ParserFeatureSetterFactory.newSAXParser(properties);</span>
<span class="nc" id="L708">            } else {</span>
                // The user doesn't want to use any non-portable parsing features,
                // so we can just use the portable API here. Note that method
                // getFactory returns a factory already configured with the
                // appropriate namespaceAware and validating properties.

<span class="fc" id="L714">                parser = getFactory().newSAXParser();</span>
            }
<span class="nc" id="L716">        } catch (Exception e) {</span>
<span class="nc" id="L717">            log.error(&quot;Digester.getParser: &quot;, e);</span>
<span class="nc" id="L718">            return (null);</span>
<span class="fc" id="L719">        }</span>

<span class="fc" id="L721">        return (parser);</span>

    }


    /**
     * Return the current value of the specified property for the underlying
     * &lt;code&gt;XMLReader&lt;/code&gt; implementation.
     * See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt;
     * for information about the standard SAX2 properties.
     *
     * @param property Property name to be retrieved
     *
     * @exception SAXNotRecognizedException if the property name is
     *  not recognized
     * @exception SAXNotSupportedException if the property name is
     *  recognized but not supported
     */
    public Object getProperty(String property)
        throws SAXNotRecognizedException, SAXNotSupportedException {

<span class="nc" id="L742">        return (getParser().getProperty(property));</span>

    }


    /**
     * Set the current value of the specified property for the underlying
     * &lt;code&gt;XMLReader&lt;/code&gt; implementation.
     * See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt;
     * for information about the standard SAX2 properties.
     *
     * @param property Property name to be set
     * @param value Property value to be set
     *
     * @exception SAXNotRecognizedException if the property name is
     *  not recognized
     * @exception SAXNotSupportedException if the property name is
     *  recognized but not supported
     */
    public void setProperty(String property, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

<span class="nc" id="L764">        getParser().setProperty(property, value);</span>

<span class="nc" id="L766">    }</span>


    /**
     * By setting the reader in the constructor, you can bypass JAXP and
     * be able to use digester in Weblogic 6.0.  
     *
     * @deprecated Use getXMLReader() instead, which can throw a
     *  SAXException if the reader cannot be instantiated
     */
    public XMLReader getReader() {

        try {
<span class="nc" id="L779">            return (getXMLReader());</span>
<span class="nc" id="L780">        } catch (SAXException e) {</span>
<span class="nc" id="L781">            log.error(&quot;Cannot get XMLReader&quot;, e);</span>
<span class="nc" id="L782">            return (null);</span>
        }

    }


    /**
     * Return the &lt;code&gt;Rules&lt;/code&gt; implementation object containing our
     * rules collection and associated matching policy.  If none has been
     * established, a default implementation will be created and returned.
     */
    public Rules getRules() {

<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (this.rules == null) {</span>
<span class="fc" id="L796">            this.rules = new RulesBase();</span>
<span class="fc" id="L797">            this.rules.setDigester(this);</span>
        }
<span class="fc" id="L799">        return (this.rules);</span>

    }

    
    /**
     * Set the &lt;code&gt;Rules&lt;/code&gt; implementation object containing our
     * rules collection and associated matching policy.
     *
     * @param rules New Rules implementation
     */
    public void setRules(Rules rules) {

<span class="fc" id="L812">        this.rules = rules;</span>
<span class="fc" id="L813">        this.rules.setDigester(this);</span>

<span class="fc" id="L815">    }</span>


    /**
     * Return the XML Schema URI used for validating an XML instance.
     */
    public String getSchema() {

<span class="nc" id="L823">        return (this.schemaLocation);</span>

    }


    /**
     * Set the XML Schema URI used for validating the input XML.
     * &lt;p&gt;
     * It is often desirable to &lt;i&gt;force&lt;/i&gt; the input document to be
     * validated against a particular schema regardless of what type
     * the input document declares itself to be. This method allows that
     * to be done. 
     * &lt;p&gt;
     * Note, however, that there is no standard API for enabling this
     * feature on the underlying SAX parser; this method therefore only works 
     * for those parsers explicitly supported by Digester's
     * ParserFeatureSetterFactory class. If the underlying parser does not
     * support the feature, or is not one of the supported parsers, then
     * an exception will be thrown when getParser is called (explicitly, 
     * or implicitly via the parse method).
     * &lt;p&gt;
     * See also method setSchemaLanguage which allows the type of the schema
     * specified here to be defined. By default, the schema is expected to
     * be a W3C xml schema definition.
     * &lt;p&gt;
     * IMPORTANT NOTE: This functionality was never very reliable, and has
     * been horribly broken since the 1.6 release of Digester. There are
     * currently no plans to fix it, so you are strongly recommended to
     * avoid using this method. Instead, create an XMLParser instance
     * yourself, configure validation appropriately, and pass it as a
     * parameter to the Digester constructor.
     *
     * @param schemaLocation a URI to the schema.
     */
    public void setSchema(String schemaLocation){

<span class="nc" id="L859">        this.schemaLocation = schemaLocation;</span>

<span class="nc" id="L861">    }   </span>
    

    /**
     * Return the XML Schema language used when parsing.
     */
    public String getSchemaLanguage() {

<span class="nc" id="L869">        return (this.schemaLanguage);</span>

    }


    /**
     * Set the XML Schema language used when parsing. By default, we use W3C.
     *
     * @param schemaLanguage a URI to the schema language.
     */
    public void setSchemaLanguage(String schemaLanguage){

<span class="nc" id="L881">        this.schemaLanguage = schemaLanguage;</span>

<span class="nc" id="L883">    }   </span>


    /**
     * Return the boolean as to whether the context classloader should be used.
     */
    public boolean getUseContextClassLoader() {

<span class="nc" id="L891">        return useContextClassLoader;</span>

    }


    /**
     * Determine whether to use the Context ClassLoader (the one found by
     * calling &lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt;)
     * to resolve/load classes that are defined in various rules.  If not
     * using Context ClassLoader, then the class-loading defaults to
     * using the calling-class' ClassLoader.
     *
     * @param use determines whether to use Context ClassLoader.
     */
    public void setUseContextClassLoader(boolean use) {

<span class="nc" id="L907">        useContextClassLoader = use;</span>

<span class="nc" id="L909">    }</span>


    /**
     * Return the validating parser flag.
     */
    public boolean getValidating() {

<span class="fc" id="L917">        return (this.validating);</span>

    }


    /**
     * Set the validating parser flag.  This must be called before
     * &lt;code&gt;parse()&lt;/code&gt; is called the first time.
     *
     * @param validating The new validating parser flag.
     */
    public void setValidating(boolean validating) {

<span class="fc" id="L930">        this.validating = validating;</span>

<span class="fc" id="L932">    }</span>


    /**
     * Return the XMLReader to be used for parsing the input document.
     *
     * FIX ME: there is a bug in JAXP/XERCES that prevent the use of a 
     * parser that contains a schema with a DTD.
     * @exception SAXException if no XMLReader can be instantiated
     */
    public XMLReader getXMLReader() throws SAXException {
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (reader == null){</span>
<span class="fc" id="L944">            reader = getParser().getXMLReader();</span>
        }        
                               
<span class="fc" id="L947">        reader.setDTDHandler(this);           </span>
<span class="fc" id="L948">        reader.setContentHandler(this);        </span>
        
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">        if (entityResolver == null){</span>
<span class="fc" id="L951">            reader.setEntityResolver(this);</span>
        } else {
<span class="nc" id="L953">            reader.setEntityResolver(entityResolver);           </span>
        }
        
<span class="fc" id="L956">        reader.setErrorHandler(this);</span>
<span class="fc" id="L957">        return reader;</span>
    }

    /**
     * Gets the &lt;code&gt;Substitutor&lt;/code&gt; used to convert attributes and body text.
     * @return Substitutor, null if not substitutions are to be performed.
     */
    public Substitutor getSubstitutor() {
<span class="fc" id="L965">        return substitutor;</span>
    }
    
    /** 
     * Sets the &lt;code&gt;Substitutor&lt;/code&gt; to be used to convert attributes and body text.
     * @param substitutor the Substitutor to be used to convert attributes and body text
     * or null if not substitution of these values is to be performed.
     */
    public void setSubstitutor(Substitutor substitutor) {
<span class="fc" id="L974">        this.substitutor = substitutor;</span>
<span class="fc" id="L975">    }</span>

    /*
     * See setCustomContentHandler.
     * 
     * @since 1.7 
     */
    public ContentHandler getCustomContentHandler() {
<span class="fc" id="L983">        return customContentHandler;</span>
    }

    /** 
     * Redirects (or cancels redirecting) of SAX ContentHandler events to an
     * external object.
     * &lt;p&gt;
     * When this object's customContentHandler is non-null, any SAX events
     * received from the parser will simply be passed on to the specified 
     * object instead of this object handling them. This allows Rule classes 
     * to take control of the SAX event stream for a while in order to do 
     * custom processing. Such a rule should save the old value before setting
     * a new one, and restore the old value in order to resume normal digester
     * processing.
     * &lt;p&gt;
     * An example of a Rule which needs this feature is NodeCreateRule.
     * &lt;p&gt;
     * Note that saving the old value is probably not needed as it should always
     * be null; a custom rule that wants to take control could only have been 
     * called when there was no custom content handler. But it seems cleaner
     * to properly save/restore the value and maybe some day this will come in
     * useful.
     * &lt;p&gt;
     * Note also that this is not quite equivalent to
     * &lt;pre&gt;
     * digester.getXMLReader().setContentHandler(handler)
     * &lt;/pre&gt;
     * for these reasons:
     * &lt;ul&gt;
     * &lt;li&gt;Some xml parsers don't like having setContentHandler called after
     * parsing has started. The Aelfred parser is one example.&lt;/li&gt;
     * &lt;li&gt;Directing the events via the Digester object potentially allows
     * us to log information about those SAX events at the digester level.&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @since 1.7 
     */
    public void setCustomContentHandler(ContentHandler handler) {
<span class="fc" id="L1021">        customContentHandler = handler;</span>
<span class="fc" id="L1022">    }</span>

    /** 
     * Define a callback object which is invoked whever an object is pushed onto
     * a digester object stack, or popped off one.
     * 
     * @since 1.8
     */
    public void setStackAction(StackAction stackAction) {
<span class="fc" id="L1031">        this.stackAction = stackAction;</span>
<span class="fc" id="L1032">    }</span>

    /**
     * See setStackAction. 
     * 
     * @since 1.8
     */
    public StackAction getStackAction() {
<span class="nc" id="L1040">        return stackAction;</span>
    }

    /**
     * Get the most current namespaces for all prefixes.
     *
     * @return Map A map with namespace prefixes as keys and most current
     *             namespace URIs for the corresponding prefixes as values
     *
     * @since 1.8
     */
    public Map getCurrentNamespaces() {
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">        if (!namespaceAware) {</span>
<span class="nc" id="L1053">            log.warn(&quot;Digester is not namespace aware&quot;);</span>
        }
<span class="fc" id="L1055">        Map currentNamespaces = new HashMap();</span>
<span class="fc" id="L1056">        Iterator nsIterator = namespaces.entrySet().iterator();</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        while (nsIterator.hasNext()) {</span>
<span class="fc" id="L1058">            Map.Entry nsEntry = (Map.Entry) nsIterator.next();</span>
            try {
<span class="fc" id="L1060">                currentNamespaces.put(nsEntry.getKey(),</span>
<span class="fc" id="L1061">                    ((ArrayStack) nsEntry.getValue()).peek());</span>
<span class="nc" id="L1062">            } catch (RuntimeException e) {</span>
                // rethrow, after logging
<span class="nc" id="L1064">                log.error(e.getMessage(), e);</span>
<span class="nc" id="L1065">                throw e;</span>
<span class="fc" id="L1066">            }</span>
<span class="fc" id="L1067">        }</span>
<span class="fc" id="L1068">        return currentNamespaces;</span>
    }

    // ------------------------------------------------- ContentHandler Methods


    /**
     * Process notification of character data received from the body of
     * an XML element.
     *
     * @param buffer The characters from the XML document
     * @param start Starting offset into the buffer
     * @param length Number of characters from the buffer
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void characters(char buffer[], int start, int length)
            throws SAXException {

<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if (customContentHandler != null) {</span>
            // forward calls instead of handling them here
<span class="fc" id="L1089">            customContentHandler.characters(buffer, start, length);</span>
<span class="fc" id="L1090">            return;</span>
        }

<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1094">            saxLog.debug(&quot;characters(&quot; + new String(buffer, start, length) + &quot;)&quot;);</span>
        }

<span class="fc" id="L1097">        bodyText.append(buffer, start, length);</span>

<span class="fc" id="L1099">    }</span>


    /**
     * Process notification of the end of the document being reached.
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void endDocument() throws SAXException {

<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">            if (getCount() &gt; 1) {</span>
<span class="fc" id="L1111">                saxLog.debug(&quot;endDocument():  &quot; + getCount() +</span>
                             &quot; elements left&quot;);
            } else {
<span class="fc" id="L1114">                saxLog.debug(&quot;endDocument()&quot;);</span>
            }
        }

        // Fire &quot;finish&quot; events for all defined rules
<span class="fc" id="L1119">        Iterator rules = getRules().rules().iterator();</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        while (rules.hasNext()) {</span>
<span class="fc" id="L1121">            Rule rule = (Rule) rules.next();</span>
            try {
<span class="fc" id="L1123">                rule.finish();</span>
<span class="nc" id="L1124">            } catch (Exception e) {</span>
<span class="nc" id="L1125">                log.error(&quot;Finish event threw exception&quot;, e);</span>
<span class="nc" id="L1126">                throw createSAXException(e);</span>
<span class="nc" id="L1127">            } catch (Error e) {</span>
<span class="nc" id="L1128">                log.error(&quot;Finish event threw error&quot;, e);</span>
<span class="nc" id="L1129">                throw e;</span>
<span class="fc" id="L1130">            }</span>
<span class="fc" id="L1131">        }</span>

        // Perform final cleanup
<span class="fc" id="L1134">        clear();</span>

<span class="fc" id="L1136">    }</span>


    /**
     * Process notification of the end of an XML element being reached.
     *
     * @param namespaceURI - The Namespace URI, or the empty string if the
     *   element has no Namespace URI or if Namespace processing is not
     *   being performed.
     * @param localName - The local name (without prefix), or the empty
     *   string if Namespace processing is not being performed.
     * @param qName - The qualified XML 1.0 name (with prefix), or the
     *   empty string if qualified names are not available.
     * @exception SAXException if a parsing error is to be reported
     */
    public void endElement(String namespaceURI, String localName,
                           String qName) throws SAXException {

<span class="fc bfc" id="L1154" title="All 2 branches covered.">        if (customContentHandler != null) {</span>
            // forward calls instead of handling them here
<span class="fc" id="L1156">            customContentHandler.endElement(namespaceURI, localName, qName);</span>
<span class="fc" id="L1157">            return;</span>
        }

<span class="fc" id="L1160">        boolean debug = log.isDebugEnabled();</span>

<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">            if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1164">                saxLog.debug(&quot;endElement(&quot; + namespaceURI + &quot;,&quot; + localName +</span>
                        &quot;,&quot; + qName + &quot;)&quot;);
            }
<span class="fc" id="L1167">            log.debug(&quot;  match='&quot; + match + &quot;'&quot;);</span>
<span class="fc" id="L1168">            log.debug(&quot;  bodyText='&quot; + bodyText + &quot;'&quot;);</span>
        }

        // the actual element name is either in localName or qName, depending 
        // on whether the parser is namespace aware
<span class="fc" id="L1173">        String name = localName;</span>
<span class="pc bpc" id="L1174" title="1 of 4 branches missed.">        if ((name == null) || (name.length() &lt; 1)) {</span>
<span class="fc" id="L1175">            name = qName;</span>
        }

        // Fire &quot;body&quot; events for all relevant rules
<span class="fc" id="L1179">        List rules = (List) matches.pop();</span>
<span class="pc bpc" id="L1180" title="1 of 4 branches missed.">        if ((rules != null) &amp;&amp; (rules.size() &gt; 0)) {</span>
<span class="fc" id="L1181">            String bodyText = this.bodyText.toString();</span>
<span class="fc" id="L1182">            Substitutor substitutor = getSubstitutor();</span>
<span class="fc bfc" id="L1183" title="All 2 branches covered.">            if (substitutor!= null) {</span>
<span class="fc" id="L1184">                bodyText = substitutor.substitute(bodyText);</span>
            }
<span class="fc bfc" id="L1186" title="All 2 branches covered.">            for (int i = 0; i &lt; rules.size(); i++) {</span>
                try {
<span class="fc" id="L1188">                    Rule rule = (Rule) rules.get(i);</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">                    if (debug) {</span>
<span class="fc" id="L1190">                        log.debug(&quot;  Fire body() for &quot; + rule);</span>
                    }
<span class="fc" id="L1192">                    rule.body(namespaceURI, name, bodyText);</span>
<span class="fc" id="L1193">                } catch (Exception e) {</span>
<span class="fc" id="L1194">                    log.error(&quot;Body event threw exception&quot;, e);</span>
<span class="fc" id="L1195">                    throw createSAXException(e);</span>
<span class="nc" id="L1196">                } catch (Error e) {</span>
<span class="nc" id="L1197">                    log.error(&quot;Body event threw error&quot;, e);</span>
<span class="nc" id="L1198">                    throw e;</span>
<span class="fc" id="L1199">                }</span>
            }
<span class="fc" id="L1201">        } else {</span>
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="fc" id="L1203">                log.debug(&quot;  No rules found matching '&quot; + match + &quot;'.&quot;);</span>
            }
        }

        // Recover the body text from the surrounding element
<span class="fc" id="L1208">        bodyText = (StringBuffer) bodyTexts.pop();</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="fc" id="L1210">            log.debug(&quot;  Popping body text '&quot; + bodyText.toString() + &quot;'&quot;);</span>
        }

        // Fire &quot;end&quot; events for all relevant rules in reverse order
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">        if (rules != null) {</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">            for (int i = 0; i &lt; rules.size(); i++) {</span>
<span class="fc" id="L1216">                int j = (rules.size() - i) - 1;</span>
                try {
<span class="fc" id="L1218">                    Rule rule = (Rule) rules.get(j);</span>
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">                    if (debug) {</span>
<span class="fc" id="L1220">                        log.debug(&quot;  Fire end() for &quot; + rule);</span>
                    }
<span class="fc" id="L1222">                    rule.end(namespaceURI, name);</span>
<span class="fc" id="L1223">                } catch (Exception e) {</span>
<span class="fc" id="L1224">                    log.error(&quot;End event threw exception&quot;, e);</span>
<span class="fc" id="L1225">                    throw createSAXException(e);</span>
<span class="nc" id="L1226">                } catch (Error e) {</span>
<span class="nc" id="L1227">                    log.error(&quot;End event threw error&quot;, e);</span>
<span class="nc" id="L1228">                    throw e;</span>
<span class="fc" id="L1229">                }</span>
            }
        }

        // Recover the previous match expression
<span class="fc" id="L1234">        int slash = match.lastIndexOf('/');</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">        if (slash &gt;= 0) {</span>
<span class="fc" id="L1236">            match = match.substring(0, slash);</span>
        } else {
<span class="fc" id="L1238">            match = &quot;&quot;;</span>
        }

<span class="fc" id="L1241">    }</span>


    /**
     * Process notification that a namespace prefix is going out of scope.
     *
     * @param prefix Prefix that is going out of scope
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void endPrefixMapping(String prefix) throws SAXException {

<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1254">            saxLog.debug(&quot;endPrefixMapping(&quot; + prefix + &quot;)&quot;);</span>
        }

        // Deregister this prefix mapping
<span class="fc" id="L1258">        ArrayStack stack = (ArrayStack) namespaces.get(prefix);</span>
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">        if (stack == null) {</span>
<span class="nc" id="L1260">            return;</span>
        }
        try {
<span class="fc" id="L1263">            stack.pop();</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">            if (stack.empty())</span>
<span class="fc" id="L1265">                namespaces.remove(prefix);</span>
<span class="nc" id="L1266">        } catch (EmptyStackException e) {</span>
<span class="nc" id="L1267">            throw createSAXException(&quot;endPrefixMapping popped too many times&quot;);</span>
<span class="fc" id="L1268">        }</span>

<span class="fc" id="L1270">    }</span>


    /**
     * Process notification of ignorable whitespace received from the body of
     * an XML element.
     *
     * @param buffer The characters from the XML document
     * @param start Starting offset into the buffer
     * @param len Number of characters from the buffer
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void ignorableWhitespace(char buffer[], int start, int len)
            throws SAXException {

<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1287">            saxLog.debug(&quot;ignorableWhitespace(&quot; +</span>
                    new String(buffer, start, len) + &quot;)&quot;);
        }

        ;   // No processing required

<span class="fc" id="L1293">    }</span>


    /**
     * Process notification of a processing instruction that was encountered.
     *
     * @param target The processing instruction target
     * @param data The processing instruction data (if any)
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void processingInstruction(String target, String data)
            throws SAXException {

<span class="nc bnc" id="L1307" title="All 2 branches missed.">        if (customContentHandler != null) {</span>
            // forward calls instead of handling them here
<span class="nc" id="L1309">            customContentHandler.processingInstruction(target, data);</span>
<span class="nc" id="L1310">            return;</span>
        }

<span class="nc bnc" id="L1313" title="All 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="nc" id="L1314">            saxLog.debug(&quot;processingInstruction('&quot; + target + &quot;','&quot; + data + &quot;')&quot;);</span>
        }

        ;   // No processing is required

<span class="nc" id="L1319">    }</span>


    /**
     * Gets the document locator associated with our parser.
     *
     * @return the Locator supplied by the document parser
     */
    public Locator getDocumentLocator() {

<span class="fc" id="L1329">        return locator;</span>

    }

    /**
     * Sets the document locator associated with our parser.
     *
     * @param locator The new locator
     */
    public void setDocumentLocator(Locator locator) {

<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1341">            saxLog.debug(&quot;setDocumentLocator(&quot; + locator + &quot;)&quot;);</span>
        }

<span class="fc" id="L1344">        this.locator = locator;</span>

<span class="fc" id="L1346">    }</span>


    /**
     * Process notification of a skipped entity.
     *
     * @param name Name of the skipped entity
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void skippedEntity(String name) throws SAXException {

<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="nc" id="L1359">            saxLog.debug(&quot;skippedEntity(&quot; + name + &quot;)&quot;);</span>
        }

        ; // No processing required

<span class="nc" id="L1364">    }</span>


    /**
     * Process notification of the beginning of the document being reached.
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void startDocument() throws SAXException {

<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1375">            saxLog.debug(&quot;startDocument()&quot;);</span>
        }

        // ensure that the digester is properly configured, as 
        // the digester could be used as a SAX ContentHandler
        // rather than via the parse() methods.
<span class="fc" id="L1381">        configure();</span>
<span class="fc" id="L1382">    }</span>


    /**
     * Process notification of the start of an XML element being reached.
     *
     * @param namespaceURI The Namespace URI, or the empty string if the element
     *   has no Namespace URI or if Namespace processing is not being performed.
     * @param localName The local name (without prefix), or the empty
     *   string if Namespace processing is not being performed.
     * @param qName The qualified name (with prefix), or the empty
     *   string if qualified names are not available.\
     * @param list The attributes attached to the element. If there are
     *   no attributes, it shall be an empty Attributes object. 
     * @exception SAXException if a parsing error is to be reported
     */
    public void startElement(String namespaceURI, String localName,
                             String qName, Attributes list)
            throws SAXException {
<span class="fc" id="L1401">        boolean debug = log.isDebugEnabled();</span>
        
<span class="fc bfc" id="L1403" title="All 2 branches covered.">        if (customContentHandler != null) {</span>
            // forward calls instead of handling them here
<span class="fc" id="L1405">            customContentHandler.startElement(namespaceURI, localName, qName, list);</span>
<span class="fc" id="L1406">            return;</span>
        }

<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1410">            saxLog.debug(&quot;startElement(&quot; + namespaceURI + &quot;,&quot; + localName + &quot;,&quot; +</span>
                    qName + &quot;)&quot;);
        }
        
        // Save the body text accumulated for our surrounding element
<span class="fc" id="L1415">        bodyTexts.push(bodyText);</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L1417">            log.debug(&quot;  Pushing body text '&quot; + bodyText.toString() + &quot;'&quot;);</span>
        }
<span class="fc" id="L1419">        bodyText = new StringBuffer();</span>

        // the actual element name is either in localName or qName, depending 
        // on whether the parser is namespace aware
<span class="fc" id="L1423">        String name = localName;</span>
<span class="pc bpc" id="L1424" title="1 of 4 branches missed.">        if ((name == null) || (name.length() &lt; 1)) {</span>
<span class="fc" id="L1425">            name = qName;</span>
        }

        // Compute the current matching rule
<span class="fc" id="L1429">        StringBuffer sb = new StringBuffer(match);</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        if (match.length() &gt; 0) {</span>
<span class="fc" id="L1431">            sb.append('/');</span>
        }
<span class="fc" id="L1433">        sb.append(name);</span>
<span class="fc" id="L1434">        match = sb.toString();</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L1436">            log.debug(&quot;  New match='&quot; + match + &quot;'&quot;);</span>
        }

        // Fire &quot;begin&quot; events for all relevant rules
<span class="fc" id="L1440">        List rules = getRules().match(namespaceURI, match);</span>
<span class="fc" id="L1441">        matches.push(rules);</span>
<span class="pc bpc" id="L1442" title="1 of 4 branches missed.">        if ((rules != null) &amp;&amp; (rules.size() &gt; 0)) {</span>
<span class="fc" id="L1443">            Substitutor substitutor = getSubstitutor();</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">            if (substitutor!= null) {</span>
<span class="fc" id="L1445">                list = substitutor.substitute(list);</span>
            }
<span class="fc bfc" id="L1447" title="All 2 branches covered.">            for (int i = 0; i &lt; rules.size(); i++) {</span>
                try {
<span class="fc" id="L1449">                    Rule rule = (Rule) rules.get(i);</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">                    if (debug) {</span>
<span class="fc" id="L1451">                        log.debug(&quot;  Fire begin() for &quot; + rule);</span>
                    }
<span class="fc" id="L1453">                    rule.begin(namespaceURI, name, list);</span>
<span class="fc" id="L1454">                } catch (Exception e) {</span>
<span class="fc" id="L1455">                    log.error(&quot;Begin event threw exception&quot;, e);</span>
<span class="fc" id="L1456">                    throw createSAXException(e);</span>
<span class="nc" id="L1457">                } catch (Error e) {</span>
<span class="nc" id="L1458">                    log.error(&quot;Begin event threw error&quot;, e);</span>
<span class="nc" id="L1459">                    throw e;</span>
<span class="fc" id="L1460">                }</span>
            }
<span class="fc" id="L1462">        } else {</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">            if (debug) {</span>
<span class="fc" id="L1464">                log.debug(&quot;  No rules found matching '&quot; + match + &quot;'.&quot;);</span>
            }
        }

<span class="fc" id="L1468">    }</span>


    /**
     * Process notification that a namespace prefix is coming in to scope.
     *
     * @param prefix Prefix that is being declared
     * @param namespaceURI Corresponding namespace URI being mapped to
     *
     * @exception SAXException if a parsing error is to be reported
     */
    public void startPrefixMapping(String prefix, String namespaceURI)
            throws SAXException {

<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1483">            saxLog.debug(&quot;startPrefixMapping(&quot; + prefix + &quot;,&quot; + namespaceURI + &quot;)&quot;);</span>
        }

        // Register this prefix mapping
<span class="fc" id="L1487">        ArrayStack stack = (ArrayStack) namespaces.get(prefix);</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">        if (stack == null) {</span>
<span class="fc" id="L1489">            stack = new ArrayStack();</span>
<span class="fc" id="L1490">            namespaces.put(prefix, stack);</span>
        }
<span class="fc" id="L1492">        stack.push(namespaceURI);</span>

<span class="fc" id="L1494">    }</span>


    // ----------------------------------------------------- DTDHandler Methods


    /**
     * Receive notification of a notation declaration event.
     *
     * @param name The notation name
     * @param publicId The public identifier (if any)
     * @param systemId The system identifier (if any)
     */
    public void notationDecl(String name, String publicId, String systemId) {

<span class="nc bnc" id="L1509" title="All 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="nc" id="L1510">            saxLog.debug(&quot;notationDecl(&quot; + name + &quot;,&quot; + publicId + &quot;,&quot; +</span>
                    systemId + &quot;)&quot;);
        }

<span class="nc" id="L1514">    }</span>


    /**
     * Receive notification of an unparsed entity declaration event.
     *
     * @param name The unparsed entity name
     * @param publicId The public identifier (if any)
     * @param systemId The system identifier (if any)
     * @param notation The name of the associated notation
     */
    public void unparsedEntityDecl(String name, String publicId,
                                   String systemId, String notation) {

<span class="nc bnc" id="L1528" title="All 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="nc" id="L1529">            saxLog.debug(&quot;unparsedEntityDecl(&quot; + name + &quot;,&quot; + publicId + &quot;,&quot; +</span>
                    systemId + &quot;,&quot; + notation + &quot;)&quot;);
        }

<span class="nc" id="L1533">    }</span>


    // ----------------------------------------------- EntityResolver Methods

    /**
     * Set the &lt;code&gt;EntityResolver&lt;/code&gt; used by SAX when resolving
     * public id and system id.
     * This must be called before the first call to &lt;code&gt;parse()&lt;/code&gt;.
     * @param entityResolver a class that implement the &lt;code&gt;EntityResolver&lt;/code&gt; interface.
     */
    public void setEntityResolver(EntityResolver entityResolver){
<span class="nc" id="L1545">        this.entityResolver = entityResolver;</span>
<span class="nc" id="L1546">    }</span>
    
    
    /**
     * Return the Entity Resolver used by the SAX parser.
     * @return Return the Entity Resolver used by the SAX parser.
     */
    public EntityResolver getEntityResolver(){
<span class="nc" id="L1554">        return entityResolver;</span>
    }

    /**
     * Resolve the requested external entity.
     *
     * @param publicId The public identifier of the entity being referenced
     * @param systemId The system identifier of the entity being referenced
     *
     * @exception SAXException if a parsing exception occurs
     * 
     */
    public InputSource resolveEntity(String publicId, String systemId)
            throws SAXException {     
                
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">        if (saxLog.isDebugEnabled()) {</span>
<span class="fc" id="L1570">            saxLog.debug(&quot;resolveEntity('&quot; + publicId + &quot;', '&quot; + systemId + &quot;')&quot;);</span>
        }
        
<span class="fc bfc" id="L1573" title="All 2 branches covered.">        if (publicId != null)</span>
<span class="fc" id="L1574">            this.publicId = publicId;</span>
                                       
        // Has this system identifier been registered?
<span class="fc" id="L1577">        URL entityURL = null;</span>
<span class="fc bfc" id="L1578" title="All 2 branches covered.">        if (publicId != null) {</span>
<span class="fc" id="L1579">            entityURL = (URL) entityValidator.get(publicId);</span>
        }
         
        // Redirect the schema location to a local destination
<span class="pc bpc" id="L1583" title="5 of 6 branches missed.">        if (schemaLocation != null &amp;&amp; entityURL == null &amp;&amp; systemId != null){</span>
<span class="nc" id="L1584">            entityURL = (URL) entityValidator.get(systemId);</span>
        } 

<span class="fc bfc" id="L1587" title="All 2 branches covered.">        if (entityURL == null) { </span>
<span class="pc bpc" id="L1588" title="1 of 2 branches missed.">            if (systemId == null) {</span>
                // cannot resolve
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="nc" id="L1591">                    log.debug(&quot; Cannot resolve entity: '&quot; + entityURL + &quot;'&quot;);</span>
                }
<span class="nc" id="L1593">                return (null);</span>
                
            } else {
                // try to resolve using system ID
<span class="pc bpc" id="L1597" title="1 of 2 branches missed.">                if (log.isDebugEnabled()) {</span>
<span class="fc" id="L1598">                    log.debug(&quot; Trying to resolve using system ID '&quot; + systemId + &quot;'&quot;);</span>
                } 
                try {
<span class="fc" id="L1601">                    entityURL = new URL(systemId);</span>
<span class="nc" id="L1602">                } catch (MalformedURLException e) {</span>
<span class="nc" id="L1603">                    throw new IllegalArgumentException(&quot;Malformed URL '&quot; + systemId</span>
<span class="nc" id="L1604">                        + &quot;' : &quot; + e.getMessage());</span>
<span class="fc" id="L1605">                }</span>
            }
        }
        
        // Return an input source to our alternative URL
<span class="pc bpc" id="L1610" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="fc" id="L1611">            log.debug(&quot; Resolving to alternate DTD '&quot; + entityURL + &quot;'&quot;);</span>
        }  
        
        try {
<span class="fc" id="L1615">            return createInputSourceFromURL(entityURL);</span>
<span class="nc" id="L1616">        } catch (Exception e) {</span>
<span class="nc" id="L1617">            throw createSAXException(e);</span>
        }
    }


    // ------------------------------------------------- ErrorHandler Methods


    /**
     * Forward notification of a parsing error to the application supplied
     * error handler (if any).
     *
     * @param exception The error information
     *
     * @exception SAXException if a parsing exception occurs
     */
    public void error(SAXParseException exception) throws SAXException {

<span class="nc" id="L1635">        log.error(&quot;Parse Error at line &quot; + exception.getLineNumber() +</span>
<span class="nc" id="L1636">                &quot; column &quot; + exception.getColumnNumber() + &quot;: &quot; +</span>
<span class="nc" id="L1637">                exception.getMessage(), exception);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">        if (errorHandler != null) {</span>
<span class="nc" id="L1639">            errorHandler.error(exception);</span>
        }

<span class="nc" id="L1642">    }</span>


    /**
     * Forward notification of a fatal parsing error to the application
     * supplied error handler (if any).
     *
     * @param exception The fatal error information
     *
     * @exception SAXException if a parsing exception occurs
     */
    public void fatalError(SAXParseException exception) throws SAXException {

<span class="nc" id="L1655">        log.error(&quot;Parse Fatal Error at line &quot; + exception.getLineNumber() +</span>
<span class="nc" id="L1656">                &quot; column &quot; + exception.getColumnNumber() + &quot;: &quot; +</span>
<span class="nc" id="L1657">                exception.getMessage(), exception);</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        if (errorHandler != null) {</span>
<span class="nc" id="L1659">            errorHandler.fatalError(exception);</span>
        }

<span class="nc" id="L1662">    }</span>


    /**
     * Forward notification of a parse warning to the application supplied
     * error handler (if any).
     *
     * @param exception The warning information
     *
     * @exception SAXException if a parsing exception occurs
     */
    public void warning(SAXParseException exception) throws SAXException {
<span class="nc bnc" id="L1674" title="All 2 branches missed.">         if (errorHandler != null) {</span>
<span class="nc" id="L1675">            log.warn(&quot;Parse Warning Error at line &quot; + exception.getLineNumber() +</span>
<span class="nc" id="L1676">                &quot; column &quot; + exception.getColumnNumber() + &quot;: &quot; +</span>
<span class="nc" id="L1677">                exception.getMessage(), exception);</span>
            
<span class="nc" id="L1679">            errorHandler.warning(exception);</span>
        }

<span class="nc" id="L1682">    }</span>


    // ------------------------------------------------------- Public Methods


    /**
     * Log a message to our associated logger.
     *
     * @param message The message to be logged
     * @deprecated Call getLogger() and use it's logging methods
     */
    public void log(String message) {

<span class="nc" id="L1696">        log.info(message);</span>

<span class="nc" id="L1698">    }</span>


    /**
     * Log a message and exception to our associated logger.
     *
     * @param message The message to be logged
     * @deprecated Call getLogger() and use it's logging methods
     */
    public void log(String message, Throwable exception) {

<span class="nc" id="L1709">        log.error(message, exception);</span>

<span class="nc" id="L1711">    }</span>


    /**
     * Parse the content of the specified file using this Digester.  Returns
     * the root element from the object stack (if any).
     *
     * @param file File containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     */
    public Object parse(File file) throws IOException, SAXException {

<span class="fc" id="L1725">        configure();</span>
<span class="fc" id="L1726">        InputSource input = new InputSource(new FileInputStream(file));</span>
<span class="fc" id="L1727">        input.setSystemId(file.toURL().toString());</span>
<span class="fc" id="L1728">        getXMLReader().parse(input);</span>
<span class="fc" id="L1729">        cleanup();</span>
<span class="fc" id="L1730">        return (root);</span>

    }   
    /**
     * Parse the content of the specified input source using this Digester.
     * Returns the root element from the object stack (if any).
     *
     * @param input Input source containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     */
    public Object parse(InputSource input) throws IOException, SAXException {
 
<span class="fc" id="L1744">        configure();</span>
<span class="fc" id="L1745">        getXMLReader().parse(input);</span>
<span class="fc" id="L1746">        cleanup();</span>
<span class="fc" id="L1747">        return (root);</span>

    }


    /**
     * Parse the content of the specified input stream using this Digester.
     * Returns the root element from the object stack (if any).
     *
     * @param input Input stream containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     */
    public Object parse(InputStream input) throws IOException, SAXException {

<span class="fc" id="L1763">        configure();</span>
<span class="fc" id="L1764">        InputSource is = new InputSource(input);</span>
<span class="fc" id="L1765">        getXMLReader().parse(is);</span>
<span class="fc" id="L1766">        cleanup();</span>
<span class="fc" id="L1767">        return (root);</span>

    }


    /**
     * Parse the content of the specified reader using this Digester.
     * Returns the root element from the object stack (if any).
     *
     * @param reader Reader containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     */
    public Object parse(Reader reader) throws IOException, SAXException {

<span class="fc" id="L1783">        configure();</span>
<span class="fc" id="L1784">        InputSource is = new InputSource(reader);</span>
<span class="fc" id="L1785">        getXMLReader().parse(is);</span>
<span class="fc" id="L1786">        cleanup();</span>
<span class="fc" id="L1787">        return (root);</span>

    }


    /**
     * Parse the content of the specified URI using this Digester.
     * Returns the root element from the object stack (if any).
     *
     * @param uri URI containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     */
    public Object parse(String uri) throws IOException, SAXException {

<span class="fc" id="L1803">        configure();</span>
<span class="fc" id="L1804">        InputSource is = createInputSourceFromURL(uri);</span>
<span class="fc" id="L1805">        getXMLReader().parse(is);</span>
<span class="fc" id="L1806">        cleanup();</span>
<span class="fc" id="L1807">        return (root);</span>

    }


    /**
     * Parse the content of the specified URL using this Digester.
     * Returns the root element from the object stack (if any).
     *
     * @param urL URL containing the XML data to be parsed
     *
     * @exception IOException if an input/output error occurs
     * @exception SAXException if a parsing exception occurs
     *
     * @since 1.8
     */
    public Object parse(URL url) throws IOException, SAXException {

<span class="fc" id="L1825">        configure();</span>
<span class="fc" id="L1826">        InputSource is = createInputSourceFromURL(url);</span>
<span class="fc" id="L1827">        getXMLReader().parse(is);</span>
<span class="fc" id="L1828">        cleanup();</span>
<span class="fc" id="L1829">        return (root);</span>

    }


    /**
     * &lt;p&gt;Register the specified DTD URL for the specified public identifier.
     * This must be called before the first call to &lt;code&gt;parse()&lt;/code&gt;.
     * &lt;/p&gt;&lt;p&gt;
     * &lt;code&gt;Digester&lt;/code&gt; contains an internal &lt;code&gt;EntityResolver&lt;/code&gt;
     * implementation. This maps &lt;code&gt;PUBLICID&lt;/code&gt;'s to URLs 
     * (from which the resource will be loaded). A common use case for this
     * method is to register local URLs (possibly computed at runtime by a 
     * classloader) for DTDs. This allows the performance advantage of using
     * a local version without having to ensure every &lt;code&gt;SYSTEM&lt;/code&gt;
     * URI on every processed xml document is local. This implementation provides
     * only basic functionality. If more sophisticated features are required,
     * using {@link #setEntityResolver} to set a custom resolver is recommended.
     * &lt;/p&gt;&lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This method will have no effect when a custom 
     * &lt;code&gt;EntityResolver&lt;/code&gt; has been set. (Setting a custom 
     * &lt;code&gt;EntityResolver&lt;/code&gt; overrides the internal implementation.) 
     * &lt;/p&gt;
     * @param publicId Public identifier of the DTD to be resolved
     * @param entityURL The URL to use for reading this DTD
     *
     * @since 1.8
     */
    public void register(String publicId, URL entityURL) {

<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="fc" id="L1860">            log.debug(&quot;register('&quot; + publicId + &quot;', '&quot; + entityURL + &quot;'&quot;);</span>
        }
<span class="fc" id="L1862">        entityValidator.put(publicId, entityURL);</span>

<span class="fc" id="L1864">    }</span>


    /**
     * &lt;p&gt;Convenience method that registers the string version of an entity URL
     * instead of a URL version.&lt;/p&gt;
     *
     * @param publicId Public identifier of the entity to be resolved
     * @param entityURL The URL to use for reading this entity
     */
    public void register(String publicId, String entityURL) {

<span class="pc bpc" id="L1876" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="fc" id="L1877">            log.debug(&quot;register('&quot; + publicId + &quot;', '&quot; + entityURL + &quot;'&quot;);</span>
        }
        try {
<span class="fc" id="L1880">            entityValidator.put(publicId, new URL(entityURL));</span>
<span class="nc" id="L1881">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L1882">            throw new IllegalArgumentException(&quot;Malformed URL '&quot; + entityURL</span>
<span class="nc" id="L1883">                + &quot;' : &quot; + e.getMessage());</span>
<span class="fc" id="L1884">        }</span>

<span class="fc" id="L1886">    }</span>


    /**
     * &lt;p&gt;&lt;code&gt;List&lt;/code&gt; of &lt;code&gt;InputSource&lt;/code&gt; instances
     * created by a &lt;code&gt;createInputSourceFromURL()&lt;/code&gt; method
     * call.  These represent open input streams that need to be
     * closed to avoid resource leaks, as well as potentially locked
     * JAR files on Windows.&lt;/p&gt;
     */
<span class="pc" id="L1896">    protected List inputSources = new ArrayList(5);</span>


    /**
     * Given a URL, return an InputSource that reads from that URL.
     * &lt;p&gt;
     * Ideally this function would not be needed and code could just use
     * &lt;code&gt;new InputSource(entityURL)&lt;/code&gt;. Unfortunately it appears
     * that when the entityURL points to a file within a jar archive a
     * caching mechanism inside the InputSource implementation causes a
     * file-handle to the jar file to remain open. On Windows systems
     * this then causes the jar archive file to be locked on disk
     * (&quot;in use&quot;) which makes it impossible to delete the jar file -
     * and that really stuffs up &quot;undeploy&quot; in webapps in particular.
     * &lt;p&gt;
     * In JDK1.4 and later, Apache XercesJ is used as the xml parser.
     * The InputSource object provided is converted into an XMLInputSource,
     * and eventually passed to an instance of XMLDocumentScannerImpl to
     * specify the source data to be converted into tokens for the rest
     * of the XMLReader code to handle. XMLDocumentScannerImpl calls
     * fEntityManager.startDocumentEntity(source), where fEntityManager
     * is declared in ancestor class XMLScanner to be an XMLEntityManager. In
     * that class, if the input source stream is null, then:
     * &lt;pre&gt;
     *  URL location = new URL(expandedSystemId);
     *  URLConnection connect = location.openConnection();
     *  if (connect instanceof HttpURLConnection) {
     *    setHttpProperties(connect,xmlInputSource);
     *  }
     *  stream = connect.getInputStream();
     * &lt;/pre&gt;
     * This method pretty much duplicates the standard behaviour, except
     * that it calls URLConnection.setUseCaches(false) before opening
     * the connection.
     *
     * @since 1.8
     */
    public InputSource createInputSourceFromURL(URL url)
      throws MalformedURLException, IOException {

<span class="fc" id="L1936">        URLConnection connection = url.openConnection();</span>
<span class="fc" id="L1937">        connection.setUseCaches(false);</span>
<span class="fc" id="L1938">        InputStream stream = connection.getInputStream();</span>
<span class="fc" id="L1939">        InputSource source = new InputSource(stream);</span>
<span class="fc" id="L1940">        source.setSystemId(url.toExternalForm());</span>
<span class="fc" id="L1941">        inputSources.add(source);</span>
<span class="fc" id="L1942">        return source;</span>

    }


    /**
     * &lt;p&gt;Convenience method that creates an &lt;code&gt;InputSource&lt;/code&gt;
     * from the string version of a URL.&lt;/p&gt;
     *
     * @param url URL for which to create an &lt;code&gt;InputSource&lt;/code&gt;
     *
     * @since 1.8
     */
    public InputSource createInputSourceFromURL(String url)
      throws MalformedURLException, IOException {

<span class="fc" id="L1958">        return createInputSourceFromURL(new URL(url));</span>

    }


    // --------------------------------------------------------- Rule Methods


    /**
     * &lt;p&gt;Register a new Rule matching the specified pattern.
     * This method sets the &lt;code&gt;Digester&lt;/code&gt; property on the rule.&lt;/p&gt;
     *
     * @param pattern Element matching pattern
     * @param rule Rule to be registered
     */
    public void addRule(String pattern, Rule rule) {

<span class="fc" id="L1975">        rule.setDigester(this);</span>
<span class="fc" id="L1976">        getRules().add(pattern, rule);</span>

<span class="fc" id="L1978">    }</span>


    /**
     * Register a set of Rule instances defined in a RuleSet.
     *
     * @param ruleSet The RuleSet instance to configure from
     */
    public void addRuleSet(RuleSet ruleSet) {

<span class="fc" id="L1988">        String oldNamespaceURI = getRuleNamespaceURI();</span>
<span class="fc" id="L1989">        String newNamespaceURI = ruleSet.getNamespaceURI();</span>
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">        if (log.isDebugEnabled()) {</span>
<span class="fc bfc" id="L1991" title="All 2 branches covered.">            if (newNamespaceURI == null) {</span>
<span class="fc" id="L1992">                log.debug(&quot;addRuleSet() with no namespace URI&quot;);</span>
            } else {
<span class="fc" id="L1994">                log.debug(&quot;addRuleSet() with namespace URI &quot; + newNamespaceURI);</span>
            }
        }
<span class="fc" id="L1997">        setRuleNamespaceURI(newNamespaceURI);</span>
<span class="fc" id="L1998">        ruleSet.addRuleInstances(this);</span>
<span class="fc" id="L1999">        setRuleNamespaceURI(oldNamespaceURI);</span>

<span class="fc" id="L2001">    }</span>


    /**
     * Add a &quot;bean property setter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @see BeanPropertySetterRule
     */
    public void addBeanPropertySetter(String pattern) {

<span class="nc" id="L2012">        addRule(pattern,</span>
                new BeanPropertySetterRule());

<span class="nc" id="L2015">    }</span>


    /**
     * Add a &quot;bean property setter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param propertyName Name of property to set
     * @see BeanPropertySetterRule
     */
    public void addBeanPropertySetter(String pattern,
                                      String propertyName) {

<span class="nc" id="L2028">        addRule(pattern,</span>
                new BeanPropertySetterRule(propertyName));

<span class="nc" id="L2031">    }</span>

    /**
     * Add an &quot;call method&quot; rule for a method which accepts no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @see CallMethodRule
     */
    public void addCallMethod(String pattern, String methodName) {

<span class="fc" id="L2042">        addRule(</span>
                pattern,
                new CallMethodRule(methodName));

<span class="fc" id="L2046">    }</span>

    /**
     * Add an &quot;call method&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero
     *  for a single parameter from the body of this element)
     * @see CallMethodRule
     */
    public void addCallMethod(String pattern, String methodName,
                              int paramCount) {

<span class="fc" id="L2060">        addRule(pattern,</span>
                new CallMethodRule(methodName, paramCount));

<span class="fc" id="L2063">    }</span>


    /**
     * Add an &quot;call method&quot; rule for the specified parameters.
     * If &lt;code&gt;paramCount&lt;/code&gt; is set to zero the rule will use
     * the body of the matched element as the single argument of the
     * method, unless &lt;code&gt;paramTypes&lt;/code&gt; is null or empty, in this
     * case the rule will call the specified method with no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero
     *  for a single parameter from the body of this element)
     * @param paramTypes Set of Java class names for the types
     *  of the expected parameters
     *  (if you wish to use a primitive type, specify the corresonding
     *  Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt;
     *  for a &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see CallMethodRule
     */
    public void addCallMethod(String pattern, String methodName,
                              int paramCount, String paramTypes[]) {

<span class="fc" id="L2087">        addRule(pattern,</span>
                new CallMethodRule(
                                    methodName,
                                    paramCount, 
                                    paramTypes));

<span class="fc" id="L2093">    }</span>


    /**
     * Add an &quot;call method&quot; rule for the specified parameters.
     * If &lt;code&gt;paramCount&lt;/code&gt; is set to zero the rule will use
     * the body of the matched element as the single argument of the
     * method, unless &lt;code&gt;paramTypes&lt;/code&gt; is null or empty, in this
     * case the rule will call the specified method with no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero
     *  for a single parameter from the body of this element)
     * @param paramTypes The Java class names of the arguments
     *  (if you wish to use a primitive type, specify the corresonding
     *  Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt;
     *  for a &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see CallMethodRule
     */
    public void addCallMethod(String pattern, String methodName,
                              int paramCount, Class paramTypes[]) {

<span class="fc" id="L2116">        addRule(pattern,</span>
                new CallMethodRule(
                                    methodName,
                                    paramCount, 
                                    paramTypes));

<span class="fc" id="L2122">    }</span>


    /**
     * Add a &quot;call parameter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param paramIndex Zero-relative parameter index to set
     *  (from the body of this element)
     * @see CallParamRule
     */
    public void addCallParam(String pattern, int paramIndex) {

<span class="fc" id="L2135">        addRule(pattern,</span>
                new CallParamRule(paramIndex));

<span class="fc" id="L2138">    }</span>


    /**
     * Add a &quot;call parameter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param paramIndex Zero-relative parameter index to set
     *  (from the specified attribute)
     * @param attributeName Attribute whose value is used as the
     *  parameter value
     * @see CallParamRule
     */
    public void addCallParam(String pattern, int paramIndex,
                             String attributeName) {

<span class="fc" id="L2154">        addRule(pattern,</span>
                new CallParamRule(paramIndex, attributeName));

<span class="fc" id="L2157">    }</span>


    /**
     * Add a &quot;call parameter&quot; rule.
     * This will either take a parameter from the stack 
     * or from the current element body text. 
     *
     * @param paramIndex The zero-relative parameter number
     * @param fromStack Should the call parameter be taken from the top of the stack?
     * @see CallParamRule
     */    
    public void addCallParam(String pattern, int paramIndex, boolean fromStack) {
    
<span class="fc" id="L2171">        addRule(pattern,</span>
                new CallParamRule(paramIndex, fromStack));
      
<span class="fc" id="L2174">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from the stack.
     * This takes a parameter from the given position on the stack.
     *
     * @param paramIndex The zero-relative parameter number
     * @param stackIndex set the call parameter to the stackIndex'th object down the stack,
     * where 0 is the top of the stack, 1 the next element down and so on
     * @see CallMethodRule
     */    
    public void addCallParam(String pattern, int paramIndex, int stackIndex) {
    
<span class="fc" id="L2187">        addRule(pattern,</span>
                new CallParamRule(paramIndex, stackIndex));
      
<span class="fc" id="L2190">    }</span>
    
    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from the current 
     * &lt;code&gt;Digester&lt;/code&gt; matching path.
     * This is sometimes useful when using rules that support wildcards.
     *
     * @param pattern the pattern that this rule should match
     * @param paramIndex The zero-relative parameter number
     * @see CallMethodRule
     */
    public void addCallParamPath(String pattern,int paramIndex) {
<span class="fc" id="L2202">        addRule(pattern, new PathCallParamRule(paramIndex));</span>
<span class="fc" id="L2203">    }</span>
    
    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from a 
     * caller-provided object. This can be used to pass constants such as
     * strings to methods; it can also be used to pass mutable objects,
     * providing ways for objects to do things like &quot;register&quot; themselves
     * with some shared object.
     * &lt;p&gt;
     * Note that when attempting to locate a matching method to invoke,
     * the true type of the paramObj is used, so that despite the paramObj
     * being passed in here as type Object, the target method can declare
     * its parameters as being the true type of the object (or some ancestor
     * type, according to the usual type-conversion rules).
     *
     * @param paramIndex The zero-relative parameter number
     * @param paramObj Any arbitrary object to be passed to the target
     * method.
     * @see CallMethodRule
     *
     * @since 1.6
     */    
    public void addObjectParam(String pattern, int paramIndex, 
                               Object paramObj) {
    
<span class="nc" id="L2228">        addRule(pattern,</span>
                new ObjectParamRule(paramIndex, paramObj));
      
<span class="nc" id="L2231">    }</span>
    
    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     * Exceptions thrown during the object creation process will be propagated.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern, String className) {

<span class="nc" id="L2243">        addFactoryCreate(pattern, className, false);</span>

<span class="nc" id="L2245">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     * Exceptions thrown during the object creation process will be propagated.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern, Class clazz) {

<span class="nc" id="L2258">        addFactoryCreate(pattern, clazz, false);</span>

<span class="nc" id="L2260">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     * Exceptions thrown during the object creation process will be propagated.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the
     *  value specified by &lt;code&gt;className&lt;/code&gt;
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern, String className,
                                 String attributeName) {

<span class="nc" id="L2276">        addFactoryCreate(pattern, className, attributeName, false);</span>

<span class="nc" id="L2278">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     * Exceptions thrown during the object creation process will be propagated.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the
     *  value specified by &lt;code&gt;className&lt;/code&gt;
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern, Class clazz,
                                 String attributeName) {

<span class="nc" id="L2294">        addFactoryCreate(pattern, clazz, attributeName, false);</span>

<span class="nc" id="L2296">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     * Exceptions thrown during the object creation process will be propagated.
     *
     * @param pattern Element matching pattern
     * @param creationFactory Previously instantiated ObjectCreationFactory
     *  to be utilized
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern,
                                 ObjectCreationFactory creationFactory) {

<span class="fc" id="L2311">        addFactoryCreate(pattern, creationFactory, false);</span>

<span class="fc" id="L2313">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during
     * object creation will be ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(
                                    String pattern, 
                                    String className,
                                    boolean ignoreCreateExceptions) {

<span class="fc" id="L2329">        addRule(</span>
                pattern,
                new FactoryCreateRule(className, ignoreCreateExceptions));

<span class="fc" id="L2333">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during
     * object creation will be ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(
                                    String pattern, 
                                    Class clazz,
                                    boolean ignoreCreateExceptions) {

<span class="nc" id="L2350">        addRule(</span>
                pattern,
                new FactoryCreateRule(clazz, ignoreCreateExceptions));

<span class="nc" id="L2354">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the
     *  value specified by &lt;code&gt;className&lt;/code&gt;
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during
     * object creation will be ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(
                                String pattern, 
                                String className,
                                String attributeName,
                                boolean ignoreCreateExceptions) {

<span class="fc" id="L2374">        addRule(</span>
                pattern,
                new FactoryCreateRule(className, attributeName, ignoreCreateExceptions));

<span class="fc" id="L2378">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the
     *  value specified by &lt;code&gt;className&lt;/code&gt;
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during
     * object creation will be ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(
                                    String pattern, 
                                    Class clazz,
                                    String attributeName,
                                    boolean ignoreCreateExceptions) {

<span class="fc" id="L2398">        addRule(</span>
                pattern,
                new FactoryCreateRule(clazz, attributeName, ignoreCreateExceptions));

<span class="fc" id="L2402">    }</span>


    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param creationFactory Previously instantiated ObjectCreationFactory
     *  to be utilized
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during
     * object creation will be ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate(String pattern,
                                 ObjectCreationFactory creationFactory,
                                 boolean ignoreCreateExceptions) {

<span class="fc" id="L2419">        creationFactory.setDigester(this);</span>
<span class="fc" id="L2420">        addRule(pattern,</span>
                new FactoryCreateRule(creationFactory, ignoreCreateExceptions));

<span class="fc" id="L2423">    }</span>

    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate(String pattern, String className) {

<span class="fc" id="L2434">        addRule(pattern,</span>
                new ObjectCreateRule(className));

<span class="fc" id="L2437">    }</span>


    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate(String pattern, Class clazz) {

<span class="fc" id="L2449">        addRule(pattern,</span>
                new ObjectCreateRule(clazz));

<span class="fc" id="L2452">    }</span>


    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Default Java class name to be created
     * @param attributeName Attribute name that optionally overrides
     *  the default Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate(String pattern, String className,
                                String attributeName) {

<span class="nc" id="L2467">        addRule(pattern,</span>
                new ObjectCreateRule(className, attributeName));

<span class="nc" id="L2470">    }</span>


    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param attributeName Attribute name that optionally overrides
     * @param clazz Default Java class to be created
     *  the default Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate(String pattern,
                                String attributeName,
                                Class clazz) {

<span class="nc" id="L2486">        addRule(pattern,</span>
                new ObjectCreateRule(attributeName, clazz));

<span class="nc" id="L2489">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     *
     * @since 1.6
     */
    public void addSetNestedProperties(String pattern) {
    
<span class="fc" id="L2500">        addRule(pattern, new SetNestedPropertiesRule());</span>
<span class="fc" id="L2501">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     * @param elementName elment name that a property maps to
     * @param propertyName property name of the element mapped from
     *
     * @since 1.6
     */
    public void addSetNestedProperties(String pattern, String elementName, String propertyName) {
    
<span class="nc" id="L2514">        addRule(pattern, new SetNestedPropertiesRule(elementName, propertyName));</span>
<span class="nc" id="L2515">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     * @param elementNames elment names that (in order) map to properties
     * @param propertyNames property names that (in order) elements are mapped to
     *
     * @since 1.6
     */    
    public void addSetNestedProperties(String pattern, String[] elementNames, String[] propertyNames) {
    
<span class="nc" id="L2528">        addRule(pattern, new SetNestedPropertiesRule(elementNames, propertyNames));</span>
<span class="nc" id="L2529">    }</span>


    /**
     * Add a &quot;set next&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @see SetNextRule
     */
    public void addSetNext(String pattern, String methodName) {

<span class="fc" id="L2541">        addRule(pattern,</span>
                new SetNextRule(methodName));

<span class="fc" id="L2544">    }</span>


    /**
     * Add a &quot;set next&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @param paramType Java class name of the expected parameter type
     *  (if you wish to use a primitive type, specify the corresonding
     *  Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt;
     *  for a &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see SetNextRule
     */
    public void addSetNext(String pattern, String methodName,
                           String paramType) {

<span class="fc" id="L2561">        addRule(pattern,</span>
                new SetNextRule(methodName, paramType));

<span class="fc" id="L2564">    }</span>


    /**
     * Add {@link SetRootRule} with the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the root object
     * @see SetRootRule
     */
    public void addSetRoot(String pattern, String methodName) {

<span class="fc" id="L2576">        addRule(pattern,</span>
                new SetRootRule(methodName));

<span class="fc" id="L2579">    }</span>


    /**
     * Add {@link SetRootRule} with the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the root object
     * @param paramType Java class name of the expected parameter type
     * @see SetRootRule
     */
    public void addSetRoot(String pattern, String methodName,
                           String paramType) {

<span class="nc" id="L2593">        addRule(pattern,</span>
                new SetRootRule(methodName, paramType));

<span class="nc" id="L2596">    }</span>

    /**
     * Add a &quot;set properties&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @see SetPropertiesRule
     */
    public void addSetProperties(String pattern) {

<span class="fc" id="L2606">        addRule(pattern,</span>
                new SetPropertiesRule());

<span class="fc" id="L2609">    }</span>

    /**
     * Add a &quot;set properties&quot; rule with a single overridden parameter.
     * See {@link SetPropertiesRule#SetPropertiesRule(String attributeName, String propertyName)}
     *
     * @param pattern Element matching pattern
     * @param attributeName map this attribute
     * @param propertyName to this property
     * @see SetPropertiesRule
     */
    public void addSetProperties(
                                String pattern, 
                                String attributeName,
                                String propertyName) {

<span class="fc" id="L2625">        addRule(pattern,</span>
                new SetPropertiesRule(attributeName, propertyName));

<span class="fc" id="L2628">    }</span>

    /**
     * Add a &quot;set properties&quot; rule with overridden parameters.
     * See {@link SetPropertiesRule#SetPropertiesRule(String [] attributeNames, String [] propertyNames)}
     *
     * @param pattern Element matching pattern
     * @param attributeNames names of attributes with custom mappings
     * @param propertyNames property names these attributes map to
     * @see SetPropertiesRule
     */
    public void addSetProperties(
                                String pattern, 
                                String [] attributeNames,
                                String [] propertyNames) {

<span class="fc" id="L2644">        addRule(pattern,</span>
                new SetPropertiesRule(attributeNames, propertyNames));

<span class="fc" id="L2647">    }</span>


    /**
     * Add a &quot;set property&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param name Attribute name containing the property name to be set
     * @param value Attribute name containing the property value to set
     * @see SetPropertyRule
     */
    public void addSetProperty(String pattern, String name, String value) {

<span class="fc" id="L2660">        addRule(pattern,</span>
                new SetPropertyRule(name, value));

<span class="fc" id="L2663">    }</span>


    /**
     * Add a &quot;set top&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @see SetTopRule
     */
    public void addSetTop(String pattern, String methodName) {

<span class="fc" id="L2675">        addRule(pattern,</span>
                new SetTopRule(methodName));

<span class="fc" id="L2678">    }</span>


    /**
     * Add a &quot;set top&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @param paramType Java class name of the expected parameter type
     *  (if you wish to use a primitive type, specify the corresonding
     *  Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt;
     *  for a &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see SetTopRule
     */
    public void addSetTop(String pattern, String methodName,
                          String paramType) {

<span class="fc" id="L2695">        addRule(pattern,</span>
                new SetTopRule(methodName, paramType));

<span class="fc" id="L2698">    }</span>


    // --------------------------------------------------- Object Stack Methods


    /**
     * Clear the current contents of the default object stack, the param stack,
     * all named stacks, and other internal variables. 
     * &lt;p&gt;
     * Calling this method &lt;i&gt;might&lt;/i&gt; allow another document of the same type
     * to be correctly parsed. However this method was not intended for this 
     * purpose. In general, a separate Digester object should be created for
     * each document to be parsed.
     */
    public void clear() {

<span class="fc" id="L2715">        match = &quot;&quot;;</span>
<span class="fc" id="L2716">        bodyTexts.clear();</span>
<span class="fc" id="L2717">        params.clear();</span>
<span class="fc" id="L2718">        publicId = null;</span>
<span class="fc" id="L2719">        stack.clear();</span>
<span class="fc" id="L2720">        stacksByName.clear();</span>
<span class="fc" id="L2721">        customContentHandler = null;</span>
<span class="fc" id="L2722">    }</span>


    /**
     * Return the top object on the stack without removing it.  If there are
     * no objects on the stack, return &lt;code&gt;null&lt;/code&gt;.
     */
    public Object peek() {

        try {
<span class="fc" id="L2732">            return (stack.peek());</span>
<span class="fc" id="L2733">        } catch (EmptyStackException e) {</span>
<span class="fc" id="L2734">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="fc" id="L2735">            return (null);</span>
        }

    }


    /**
     * Return the n'th object down the stack, where 0 is the top element
     * and [getCount()-1] is the bottom element.  If the specified index
     * is out of range, return &lt;code&gt;null&lt;/code&gt;.
     *
     * @param n Index of the desired element, where 0 is the top of the stack,
     *  1 is the next element down, and so on.
     */
    public Object peek(int n) {

        try {
<span class="fc" id="L2752">            return (stack.peek(n));</span>
<span class="fc" id="L2753">        } catch (EmptyStackException e) {</span>
<span class="fc" id="L2754">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="fc" id="L2755">            return (null);</span>
        }

    }


    /**
     * Pop the top object off of the stack, and return it.  If there are
     * no objects on the stack, return &lt;code&gt;null&lt;/code&gt;.
     */
    public Object pop() {

        try {
<span class="fc" id="L2768">            Object popped = stack.pop();</span>
<span class="fc bfc" id="L2769" title="All 2 branches covered.">            if (stackAction != null) {</span>
<span class="fc" id="L2770">                popped = stackAction.onPop(this, null, popped);</span>
            }
<span class="fc" id="L2772">            return popped;</span>
<span class="fc" id="L2773">        } catch (EmptyStackException e) {</span>
<span class="fc" id="L2774">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="fc" id="L2775">            return (null);</span>
        }

    }


    /**
     * Push a new object onto the top of the object stack.
     *
     * @param object The new object
     */
    public void push(Object object) {

<span class="fc bfc" id="L2788" title="All 2 branches covered.">        if (stackAction != null) {</span>
<span class="fc" id="L2789">            object = stackAction.onPush(this, null, object);</span>
        }

<span class="fc bfc" id="L2792" title="All 2 branches covered.">        if (stack.size() == 0) {</span>
<span class="fc" id="L2793">            root = object;</span>
        }
<span class="fc" id="L2795">        stack.push(object);</span>
<span class="fc" id="L2796">    }</span>

    /**
     * Pushes the given object onto the stack with the given name.
     * If no stack already exists with the given name then one will be created.
     * 
     * @param stackName the name of the stack onto which the object should be pushed
     * @param value the Object to be pushed onto the named stack.
     *
     * @since 1.6
     */
    public void push(String stackName, Object value) {
<span class="fc bfc" id="L2808" title="All 2 branches covered.">        if (stackAction != null) {</span>
<span class="fc" id="L2809">            value = stackAction.onPush(this, stackName, value);</span>
        }

<span class="fc" id="L2812">        ArrayStack namedStack = (ArrayStack) stacksByName.get(stackName);</span>
<span class="fc bfc" id="L2813" title="All 2 branches covered.">        if (namedStack == null) {</span>
<span class="fc" id="L2814">            namedStack = new ArrayStack();</span>
<span class="fc" id="L2815">            stacksByName.put(stackName, namedStack);</span>
        }
<span class="fc" id="L2817">        namedStack.push(value);</span>
<span class="fc" id="L2818">    }</span>

    /**
     * &lt;p&gt;Pops (gets and removes) the top object from the stack with the given name.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty
     * if no objects have been pushed onto it yet.&lt;/p&gt;
     * 
     * @param stackName the name of the stack from which the top value is to be popped.
     * @return the top &lt;code&gt;Object&lt;/code&gt; on the stack or or null if the stack is either 
     * empty or has not been created yet
     * @throws EmptyStackException if the named stack is empty
     *
     * @since 1.6
     */
    public Object pop(String stackName) {
<span class="fc" id="L2834">        Object result = null;</span>
<span class="fc" id="L2835">        ArrayStack namedStack = (ArrayStack) stacksByName.get(stackName);</span>
<span class="fc bfc" id="L2836" title="All 2 branches covered.">        if (namedStack == null) {</span>
<span class="pc bpc" id="L2837" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="fc" id="L2838">                log.debug(&quot;Stack '&quot; + stackName + &quot;' is empty&quot;);</span>
            }
<span class="fc" id="L2840">            throw new EmptyStackException();</span>
        }
        
<span class="fc" id="L2843">        result = namedStack.pop();</span>
        
<span class="fc bfc" id="L2845" title="All 2 branches covered.">        if (stackAction != null) {</span>
<span class="fc" id="L2846">            result = stackAction.onPop(this, stackName, result);</span>
        }

<span class="fc" id="L2849">        return result;</span>
    }
    
    /**
     * &lt;p&gt;Gets the top object from the stack with the given name.
     * This method does not remove the object from the stack.
     * &lt;/p&gt;
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty
     * if no objects have been pushed onto it yet.&lt;/p&gt;
     *
     * @param stackName the name of the stack to be peeked
     * @return the top &lt;code&gt;Object&lt;/code&gt; on the stack or null if the stack is either 
     * empty or has not been created yet
     * @throws EmptyStackException if the named stack is empty 
     *
     * @since 1.6
     */
    public Object peek(String stackName) {
<span class="fc" id="L2867">        return peek(stackName, 0);</span>
    }

    /**
     * &lt;p&gt;Gets the top object from the stack with the given name.
     * This method does not remove the object from the stack.
     * &lt;/p&gt;
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty
     * if no objects have been pushed onto it yet.&lt;/p&gt;
     *
     * @param stackName the name of the stack to be peeked
     * @param n Index of the desired element, where 0 is the top of the stack,
     *  1 is the next element down, and so on.
     * @return the specified &lt;code&gt;Object&lt;/code&gt; on the stack.
     * @throws EmptyStackException if the named stack is empty 
     *
     * @since 1.6
     */
    public Object peek(String stackName, int n) {
<span class="fc" id="L2886">        Object result = null;</span>
<span class="fc" id="L2887">        ArrayStack namedStack = (ArrayStack) stacksByName.get(stackName);</span>
<span class="fc bfc" id="L2888" title="All 2 branches covered.">        if (namedStack == null ) {</span>
<span class="pc bpc" id="L2889" title="1 of 2 branches missed.">            if (log.isDebugEnabled()) {</span>
<span class="fc" id="L2890">                log.debug(&quot;Stack '&quot; + stackName + &quot;' is empty&quot;);</span>
            }        
<span class="fc" id="L2892">            throw new EmptyStackException();</span>
        
        } else {
        
<span class="fc" id="L2896">            result = namedStack.peek(n);</span>
        }
<span class="fc" id="L2898">        return result;</span>
    }

    /**
     * &lt;p&gt;Is the stack with the given name empty?&lt;/p&gt;
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty
     * if no objects have been pushed onto it yet.&lt;/p&gt;
     * @param stackName the name of the stack whose emptiness 
     * should be evaluated
     * @return true if the given stack if empty 
     *
     * @since 1.6
     */
    public boolean isEmpty(String stackName) {
<span class="fc" id="L2912">        boolean result = true;</span>
<span class="fc" id="L2913">        ArrayStack namedStack = (ArrayStack) stacksByName.get(stackName);</span>
<span class="fc bfc" id="L2914" title="All 2 branches covered.">        if (namedStack != null ) {</span>
<span class="fc" id="L2915">            result = namedStack.isEmpty();</span>
        }
<span class="fc" id="L2917">        return result;</span>
    }
    
    /**
     * Returns the root element of the tree of objects created as a result
     * of applying the rule objects to the input XML.
     * &lt;p&gt;
     * If the digester stack was &quot;primed&quot; by explicitly pushing a root
     * object onto the stack before parsing started, then that root object
     * is returned here.
     * &lt;p&gt;
     * Alternatively, if a Rule which creates an object (eg ObjectCreateRule)
     * matched the root element of the xml, then the object created will be
     * returned here.
     * &lt;p&gt;
     * In other cases, the object most recently pushed onto an empty digester
     * stack is returned. This would be a most unusual use of digester, however;
     * one of the previous configurations is much more likely.
     * &lt;p&gt;
     * Note that when using one of the Digester.parse methods, the return
     * value from the parse method is exactly the same as the return value
     * from this method. However when the Digester is being used as a 
     * SAXContentHandler, no such return value is available; in this case, this
     * method allows you to access the root object that has been created 
     * after parsing has completed.
     * 
     * @return the root object that has been created after parsing
     *  or null if the digester has not parsed any XML yet.
     */
    public Object getRoot() {
<span class="fc" id="L2947">        return root;</span>
    }
    
    /**
     * This method allows the &quot;root&quot; variable to be reset to null.
     * &lt;p&gt;
     * It is not considered safe for a digester instance to be reused
     * to parse multiple xml documents. However if you are determined to
     * do so, then you should call both clear() and resetRoot() before
     * each parse.
     *
     * @since 1.7
     */
    public void resetRoot() {
<span class="nc" id="L2961">        root = null;</span>
<span class="nc" id="L2962">    }</span>

    // ------------------------------------------------ Parameter Stack Methods


    // ------------------------------------------------------ Protected Methods


    /**
     * &lt;p&gt;Clean up allocated resources after parsing is complete.  The
     * default method closes input streams that have been created by
     * Digester itself.  If you override this method in a subclass, be
     * sure to call &lt;code&gt;super.cleanup()&lt;/code&gt; to invoke this logic.&lt;/p&gt;
     *
     * @since 1.8
     */
    protected void cleanup() {

        // If we created any InputSource objects in this instance,
        // they each have an input stream that should be closed
<span class="fc" id="L2982">        Iterator sources = inputSources.iterator();</span>
<span class="fc bfc" id="L2983" title="All 2 branches covered.">        while (sources.hasNext()) {</span>
<span class="fc" id="L2984">            InputSource source = (InputSource) sources.next();</span>
            try {
<span class="fc" id="L2986">                source.getByteStream().close();</span>
<span class="nc" id="L2987">            } catch (IOException e) {</span>
                ; // Fall through so we get them all
<span class="fc" id="L2989">            }</span>
<span class="fc" id="L2990">        }</span>

<span class="fc" id="L2992">    }</span>


    /**
     * &lt;p&gt;
     * Provide a hook for lazy configuration of this &lt;code&gt;Digester&lt;/code&gt;
     * instance.  The default implementation does nothing, but subclasses
     * can override as needed.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt; This method may be called more than once.
     * Once only initialization code should be placed in {@link #initialize}
     * or the code should take responsibility by checking and setting the 
     * {@link #configured} flag.
     * &lt;/p&gt;
     */
    protected void configure() {

        // Do not configure more than once
<span class="fc bfc" id="L3012" title="All 2 branches covered.">        if (configured) {</span>
<span class="fc" id="L3013">            return;</span>
        }

        // Perform lazy configuration as needed
<span class="fc" id="L3017">        initialize(); // call hook method for subclasses that want to be initialized once only</span>
        // Nothing else required by default

        // Set the configuration flag to avoid repeating
<span class="fc" id="L3021">        configured = true;</span>

<span class="fc" id="L3023">    }</span>
    
    /**
     * &lt;p&gt;
     * Provides a hook for lazy initialization of this &lt;code&gt;Digester&lt;/code&gt;
     * instance.  
     * The default implementation does nothing, but subclasses
     * can override as needed.
     * Digester (by default) only calls this method once.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt; This method will be called by {@link #configure} 
     * only when the {@link #configured} flag is false. 
     * Subclasses that override &lt;code&gt;configure&lt;/code&gt; or who set &lt;code&gt;configured&lt;/code&gt;
     * may find that this method may be called more than once.
     * &lt;/p&gt;
     *
     * @since 1.6
     */
    protected void initialize() {

        // Perform lazy initialization as needed
        ; // Nothing required by default

<span class="fc" id="L3048">    }    </span>

    // -------------------------------------------------------- Package Methods


    /**
     * Return the set of DTD URL registrations, keyed by public identifier.
     */
    Map getRegistrations() {

<span class="fc" id="L3058">        return (entityValidator);</span>

    }


    /**
     * Return the set of rules that apply to the specified match position.
     * The selected rules are those that match exactly, or those rules
     * that specify a suffix match and the tail of the rule matches the
     * current match position.  Exact matches have precedence over
     * suffix matches, then (among suffix matches) the longest match
     * is preferred.
     *
     * @param match The current match position
     *
     * @deprecated Call &lt;code&gt;match()&lt;/code&gt; on the &lt;code&gt;Rules&lt;/code&gt;
     *  implementation returned by &lt;code&gt;getRules()&lt;/code&gt;
     */
    List getRules(String match) {

<span class="nc" id="L3078">        return (getRules().match(match));</span>

    }


    /**
     * &lt;p&gt;Return the top object on the parameters stack without removing it.  If there are
     * no objects on the stack, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. 
     * See {@link #params}.&lt;/p&gt;
     */
    public Object peekParams() {

        try {
<span class="fc" id="L3093">            return (params.peek());</span>
<span class="nc" id="L3094">        } catch (EmptyStackException e) {</span>
<span class="nc" id="L3095">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="nc" id="L3096">            return (null);</span>
        }

    }


    /**
     * &lt;p&gt;Return the n'th object down the parameters stack, where 0 is the top element
     * and [getCount()-1] is the bottom element.  If the specified index
     * is out of range, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. 
     * See {@link #params}.&lt;/p&gt;
     *
     * @param n Index of the desired element, where 0 is the top of the stack,
     *  1 is the next element down, and so on.
     */
    public Object peekParams(int n) {

        try {
<span class="nc" id="L3116">            return (params.peek(n));</span>
<span class="nc" id="L3117">        } catch (EmptyStackException e) {</span>
<span class="nc" id="L3118">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="nc" id="L3119">            return (null);</span>
        }

    }


    /**
     * &lt;p&gt;Pop the top object off of the parameters stack, and return it.  If there are
     * no objects on the stack, return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. 
     * See {@link #params}.&lt;/p&gt;
     */
    public Object popParams() {

        try {
<span class="pc bpc" id="L3135" title="1 of 2 branches missed.">            if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3136">                log.trace(&quot;Popping params&quot;);</span>
            }
<span class="fc" id="L3138">            return (params.pop());</span>
<span class="nc" id="L3139">        } catch (EmptyStackException e) {</span>
<span class="nc" id="L3140">            log.warn(&quot;Empty stack (returning null)&quot;);</span>
<span class="nc" id="L3141">            return (null);</span>
        }

    }


    /**
     * &lt;p&gt;Push a new object onto the top of the parameters stack.&lt;/p&gt;
     *
     * &lt;p&gt;The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. 
     * See {@link #params}.&lt;/p&gt;
     *
     * @param object The new object
     */
    public void pushParams(Object object) {
<span class="pc bpc" id="L3156" title="1 of 2 branches missed.">        if (log.isTraceEnabled()) {</span>
<span class="nc" id="L3157">            log.trace(&quot;Pushing params&quot;);</span>
        }
<span class="fc" id="L3159">        params.push(object);</span>

<span class="fc" id="L3161">    }</span>

    /**
     * Create a SAX exception which also understands about the location in
     * the digester file where the exception occurs
     *
     * @return the new exception
     */
    public SAXException createSAXException(String message, Exception e) {
<span class="pc bpc" id="L3170" title="2 of 4 branches missed.">        if ((e != null) &amp;&amp;</span>
            (e instanceof InvocationTargetException)) {
<span class="nc" id="L3172">            Throwable t = ((InvocationTargetException) e).getTargetException();</span>
<span class="nc bnc" id="L3173" title="All 4 branches missed.">            if ((t != null) &amp;&amp; (t instanceof Exception)) {</span>
<span class="nc" id="L3174">                e = (Exception) t;</span>
            }
        }
<span class="pc bpc" id="L3177" title="1 of 2 branches missed.">        if (locator != null) {</span>
<span class="fc" id="L3178">            String error = &quot;Error at line &quot; + locator.getLineNumber() + &quot; char &quot; +</span>
<span class="fc" id="L3179">                    locator.getColumnNumber() + &quot;: &quot; + message;</span>
<span class="pc bpc" id="L3180" title="1 of 2 branches missed.">            if (e != null) {</span>
<span class="fc" id="L3181">                return new SAXParseException(error, locator, e);</span>
            } else {
<span class="nc" id="L3183">                return new SAXParseException(error, locator);</span>
            }
        }
<span class="nc" id="L3186">        log.error(&quot;No Locator!&quot;);</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc" id="L3188">            return new SAXException(message, e);</span>
        } else {
<span class="nc" id="L3190">            return new SAXException(message);</span>
        }
    }

    /**
     * Create a SAX exception which also understands about the location in
     * the digester file where the exception occurs
     *
     * @return the new exception
     */
    public SAXException createSAXException(Exception e) {
<span class="pc bpc" id="L3201" title="1 of 2 branches missed.">        if (e instanceof InvocationTargetException) {</span>
<span class="nc" id="L3202">            Throwable t = ((InvocationTargetException) e).getTargetException();</span>
<span class="nc bnc" id="L3203" title="All 4 branches missed.">            if ((t != null) &amp;&amp; (t instanceof Exception)) {</span>
<span class="nc" id="L3204">                e = (Exception) t;</span>
            }
        }
<span class="fc" id="L3207">        return createSAXException(e.getMessage(), e);</span>
    }

    /**
     * Create a SAX exception which also understands about the location in
     * the digester file where the exception occurs
     *
     * @return the new exception
     */
    public SAXException createSAXException(String message) {
<span class="nc" id="L3217">        return createSAXException(message, null);</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>