<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Rule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Codec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.codec.language.bm</a> &gt; <span class="el_source">Rule.java</span></div><h1>Rule.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.language.bm;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A phoneme rule.
 * &lt;p&gt;
 * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply
 * and a logical flag indicating if all languages must be in play. A rule matches if:
 * &lt;ul&gt;
 * &lt;li&gt;the pattern matches at the current position&lt;/li&gt;
 * &lt;li&gt;the string up until the beginning of the pattern matches the left context&lt;/li&gt;
 * &lt;li&gt;the string from the end of the pattern matches the right context&lt;/li&gt;
 * &lt;li&gt;logical is ALL and all languages are in scope; or&lt;/li&gt;
 * &lt;li&gt;logical is any other value and at least one language is in scope&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user
 * to explicitly construct their own.
 * &lt;p&gt;
 * Rules are immutable and thread-safe.
 * &lt;p&gt;
 * &lt;b&gt;Rules resources&lt;/b&gt;
 * &lt;p&gt;
 * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically
 * named following the pattern:
 * &lt;blockquote&gt;org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt&lt;/blockquote&gt;
 * &lt;p&gt;
 * The format of these resources is the following:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Rules:&lt;/b&gt; whitespace separated, double-quoted strings. There should be 4 columns to each row, and these
 * will be interpreted as:
 * &lt;ol&gt;
 * &lt;li&gt;pattern&lt;/li&gt;
 * &lt;li&gt;left context&lt;/li&gt;
 * &lt;li&gt;right context&lt;/li&gt;
 * &lt;li&gt;phoneme&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;End-of-line comments:&lt;/b&gt; Any occurrence of '//' will cause all text following on that line to be discarded
 * as a comment.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Multi-line comments:&lt;/b&gt; Any line starting with '/*' will start multi-line commenting mode. This will skip
 * all content until a line ending in '*' and '/' is found.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Blank lines:&lt;/b&gt; All blank lines will be skipped.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since 1.6
 * @version $Id$
 */
public class Rule {

    public static final class Phoneme implements PhonemeExpr {
<span class="fc" id="L83">        public static final Comparator&lt;Phoneme&gt; COMPARATOR = new Comparator&lt;Phoneme&gt;() {</span>
            @Override
            public int compare(final Phoneme o1, final Phoneme o2) {
<span class="fc bfc" id="L86" title="All 2 branches covered.">                for (int i = 0; i &lt; o1.phonemeText.length(); i++) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">                    if (i &gt;= o2.phonemeText.length()) {</span>
<span class="fc" id="L88">                        return +1;</span>
                    }
<span class="fc" id="L90">                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                    if (c != 0) {</span>
<span class="fc" id="L92">                        return c;</span>
                    }
                }

<span class="fc bfc" id="L96" title="All 2 branches covered.">                if (o1.phonemeText.length() &lt; o2.phonemeText.length()) {</span>
<span class="fc" id="L97">                    return -1;</span>
                }

<span class="fc" id="L100">                return 0;</span>
            }
        };

        private final CharSequence phonemeText;
        private final Languages.LanguageSet languages;

<span class="fc" id="L107">        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {</span>
<span class="fc" id="L108">            this.phonemeText = phonemeText;</span>
<span class="fc" id="L109">            this.languages = languages;</span>
<span class="fc" id="L110">        }</span>

        public Phoneme append(final CharSequence str) {
<span class="fc" id="L113">            return new Phoneme(this.phonemeText.toString() + str.toString(), this.languages);</span>
        }

        public Languages.LanguageSet getLanguages() {
<span class="fc" id="L117">            return this.languages;</span>
        }

        @Override
        public Iterable&lt;Phoneme&gt; getPhonemes() {
<span class="fc" id="L122">            return Collections.singleton(this);</span>
        }

        public CharSequence getPhonemeText() {
<span class="fc" id="L126">            return this.phonemeText;</span>
        }

        public Phoneme join(final Phoneme right) {
<span class="fc" id="L130">            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),</span>
<span class="fc" id="L131">                               this.languages.restrictTo(right.languages));</span>
        }
    }

    public interface PhonemeExpr {
        Iterable&lt;Phoneme&gt; getPhonemes();
    }

    public static final class PhonemeList implements PhonemeExpr {
        private final List&lt;Phoneme&gt; phonemes;

<span class="fc" id="L142">        public PhonemeList(final List&lt;Phoneme&gt; phonemes) {</span>
<span class="fc" id="L143">            this.phonemes = phonemes;</span>
<span class="fc" id="L144">        }</span>

        @Override
        public List&lt;Phoneme&gt; getPhonemes() {
<span class="fc" id="L148">            return this.phonemes;</span>
        }
    }

    /**
     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.
     */
    public static interface RPattern {
        boolean isMatch(CharSequence input);
    }

<span class="fc" id="L159">    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {</span>
        @Override
        public boolean isMatch(final CharSequence input) {
<span class="fc" id="L162">            return true;</span>
        }
    };

    public static final String ALL = &quot;ALL&quot;;

    private static final String DOUBLE_QUOTE = &quot;\&quot;&quot;;

    private static final String HASH_INCLUDE = &quot;#include&quot;;

<span class="fc" id="L172">    private static final Map&lt;NameType, Map&lt;RuleType, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt; RULES =</span>
            new EnumMap&lt;NameType, Map&lt;RuleType, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt;(NameType.class);

    static {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (final NameType s : NameType.values()) {</span>
<span class="fc" id="L177">            final Map&lt;RuleType, Map&lt;String, List&lt;Rule&gt;&gt;&gt; rts =</span>
                    new EnumMap&lt;RuleType, Map&lt;String, List&lt;Rule&gt;&gt;&gt;(RuleType.class);

<span class="fc bfc" id="L180" title="All 2 branches covered.">            for (final RuleType rt : RuleType.values()) {</span>
<span class="fc" id="L181">                final Map&lt;String, List&lt;Rule&gt;&gt; rs = new HashMap&lt;String, List&lt;Rule&gt;&gt;();</span>

<span class="fc" id="L183">                final Languages ls = Languages.getInstance(s);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                for (final String l : ls.getLanguages()) {</span>
                    try {
<span class="fc" id="L186">                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));</span>
<span class="nc" id="L187">                    } catch (final IllegalStateException e) {</span>
<span class="nc" id="L188">                        throw new IllegalStateException(&quot;Problem processing &quot; + createResourceName(s, rt, l), e);</span>
<span class="fc" id="L189">                    }</span>
<span class="fc" id="L190">                }</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (!rt.equals(RuleType.RULES)) {</span>
<span class="fc" id="L192">                    rs.put(&quot;common&quot;, parseRules(createScanner(s, rt, &quot;common&quot;), createResourceName(s, rt, &quot;common&quot;)));</span>
                }

<span class="fc" id="L195">                rts.put(rt, Collections.unmodifiableMap(rs));</span>
            }

<span class="fc" id="L198">            RULES.put(s, Collections.unmodifiableMap(rts));</span>
        }
<span class="fc" id="L200">    }</span>

    private static boolean contains(final CharSequence chars, final char input) {
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (int i = 0; i &lt; chars.length(); i++) {</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (chars.charAt(i) == input) {</span>
<span class="fc" id="L205">                return true;</span>
            }
        }
<span class="fc" id="L208">        return false;</span>
    }

    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {
<span class="fc" id="L212">        return String.format(&quot;org/apache/commons/codec/language/bm/%s_%s_%s.txt&quot;,</span>
<span class="fc" id="L213">                             nameType.getName(), rt.getName(), lang);</span>
    }

    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {
<span class="fc" id="L217">        final String resName = createResourceName(nameType, rt, lang);</span>
<span class="fc" id="L218">        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);</span>

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (rulesIS == null) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;Unable to load resource: &quot; + resName);</span>
        }

<span class="fc" id="L224">        return new Scanner(rulesIS, ResourceConstants.ENCODING);</span>
    }

    private static Scanner createScanner(final String lang) {
<span class="fc" id="L228">        final String resName = String.format(&quot;org/apache/commons/codec/language/bm/%s.txt&quot;, lang);</span>
<span class="fc" id="L229">        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);</span>

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (rulesIS == null) {</span>
<span class="nc" id="L232">            throw new IllegalArgumentException(&quot;Unable to load resource: &quot; + resName);</span>
        }

<span class="fc" id="L235">        return new Scanner(rulesIS, ResourceConstants.ENCODING);</span>
    }

    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (suffix.length() &gt; input.length()) {</span>
<span class="fc" id="L240">            return false;</span>
        }
<span class="fc bfc" id="L242" title="All 2 branches covered.">        for (int i = input.length() - 1, j = suffix.length() - 1; j &gt;= 0; i--, j--) {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (input.charAt(i) != suffix.charAt(j)) {</span>
<span class="fc" id="L244">                return false;</span>
            }
        }
<span class="fc" id="L247">        return true;</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a list of Rules that apply
     */
    public static List&lt;Rule&gt; getInstance(final NameType nameType, final RuleType rt,
                                         final Languages.LanguageSet langs) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        return langs.isSingleton() ? getInstance(nameType, rt, langs.getAny()) :</span>
<span class="fc" id="L264">                                     getInstance(nameType, rt, Languages.ANY);</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a list rules for a combination of name type, rule type and a single language.
     */
    public static List&lt;Rule&gt; getInstance(final NameType nameType, final RuleType rt, final String lang) {
<span class="fc" id="L279">        final List&lt;Rule&gt; rules = RULES.get(nameType).get(rt).get(lang);</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (rules == null) {</span>
<span class="fc" id="L282">            throw new IllegalArgumentException(String.format(&quot;No rules found for %s, %s, %s.&quot;,</span>
<span class="fc" id="L283">                                               nameType.getName(), rt.getName(), lang));</span>
        }

<span class="fc" id="L286">        return rules;</span>
    }

    private static Phoneme parsePhoneme(final String ph) {
<span class="fc" id="L290">        final int open = ph.indexOf(&quot;[&quot;);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (open &gt;= 0) {</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (!ph.endsWith(&quot;]&quot;)) {</span>
<span class="nc" id="L293">                throw new IllegalArgumentException(&quot;Phoneme expression contains a '[' but does not end in ']'&quot;);</span>
            }
<span class="fc" id="L295">            final String before = ph.substring(0, open);</span>
<span class="fc" id="L296">            final String in = ph.substring(open + 1, ph.length() - 1);</span>
<span class="fc" id="L297">            final Set&lt;String&gt; langs = new HashSet&lt;String&gt;(Arrays.asList(in.split(&quot;[+]&quot;)));</span>

<span class="fc" id="L299">            return new Phoneme(before, Languages.LanguageSet.from(langs));</span>
        } else {
<span class="fc" id="L301">            return new Phoneme(ph, Languages.ANY_LANGUAGE);</span>
        }
    }

    private static PhonemeExpr parsePhonemeExpr(final String ph) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (ph.startsWith(&quot;(&quot;)) { // we have a bracketed list of options</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            if (!ph.endsWith(&quot;)&quot;)) {</span>
<span class="nc" id="L308">                throw new IllegalArgumentException(&quot;Phoneme starts with '(' so must end with ')'&quot;);</span>
            }

<span class="fc" id="L311">            final List&lt;Phoneme&gt; phs = new ArrayList&lt;Phoneme&gt;();</span>
<span class="fc" id="L312">            final String body = ph.substring(1, ph.length() - 1);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            for (final String part : body.split(&quot;[|]&quot;)) {</span>
<span class="fc" id="L314">                phs.add(parsePhoneme(part));</span>
            }
<span class="fc bfc" id="L316" title="All 4 branches covered.">            if (body.startsWith(&quot;|&quot;) || body.endsWith(&quot;|&quot;)) {</span>
<span class="fc" id="L317">                phs.add(new Phoneme(&quot;&quot;, Languages.ANY_LANGUAGE));</span>
            }

<span class="fc" id="L320">            return new PhonemeList(phs);</span>
        } else {
<span class="fc" id="L322">            return parsePhoneme(ph);</span>
        }
    }

    private static List&lt;Rule&gt; parseRules(final Scanner scanner, final String location) {
<span class="fc" id="L327">        final List&lt;Rule&gt; lines = new ArrayList&lt;Rule&gt;();</span>
<span class="fc" id="L328">        int currentLine = 0;</span>

<span class="fc" id="L330">        boolean inMultilineComment = false;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        while (scanner.hasNextLine()) {</span>
<span class="fc" id="L332">            currentLine++;</span>
<span class="fc" id="L333">            final String rawLine = scanner.nextLine();</span>
<span class="fc" id="L334">            String line = rawLine;</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">            if (inMultilineComment) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {</span>
<span class="fc" id="L338">                    inMultilineComment = false;</span>
                }
            } else {
<span class="fc bfc" id="L341" title="All 2 branches covered.">                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {</span>
<span class="fc" id="L342">                    inMultilineComment = true;</span>
                } else {
                    // discard comments
<span class="fc" id="L345">                    final int cmtI = line.indexOf(ResourceConstants.CMT);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    if (cmtI &gt;= 0) {</span>
<span class="fc" id="L347">                        line = line.substring(0, cmtI);</span>
                    }

                    // trim leading-trailing whitespace
<span class="fc" id="L351">                    line = line.trim();</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">                    if (line.length() == 0) {</span>
<span class="fc" id="L354">                        continue; // empty lines can be safely skipped</span>
                    }

<span class="fc bfc" id="L357" title="All 2 branches covered.">                    if (line.startsWith(HASH_INCLUDE)) {</span>
                        // include statement
<span class="fc" id="L359">                        final String incl = line.substring(HASH_INCLUDE.length()).trim();</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">                        if (incl.contains(&quot; &quot;)) {</span>
<span class="nc" id="L361">                            throw new IllegalArgumentException(&quot;Malformed import statement '&quot; + rawLine + &quot;' in &quot; +</span>
                                                               location);
                        } else {
<span class="fc" id="L364">                            lines.addAll(parseRules(createScanner(incl), location + &quot;-&gt;&quot; + incl));</span>
                        }
<span class="fc" id="L366">                    } else {</span>
                        // rule
<span class="fc" id="L368">                        final String[] parts = line.split(&quot;\\s+&quot;);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">                        if (parts.length != 4) {</span>
<span class="nc" id="L370">                            throw new IllegalArgumentException(&quot;Malformed rule statement split into &quot; + parts.length +</span>
                                                               &quot; parts: &quot; + rawLine + &quot; in &quot; + location);
                        } else {
                            try {
<span class="fc" id="L374">                                final String pat = stripQuotes(parts[0]);</span>
<span class="fc" id="L375">                                final String lCon = stripQuotes(parts[1]);</span>
<span class="fc" id="L376">                                final String rCon = stripQuotes(parts[2]);</span>
<span class="fc" id="L377">                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));</span>
<span class="fc" id="L378">                                final int cLine = currentLine;</span>
<span class="fc" id="L379">                                final Rule r = new Rule(pat, lCon, rCon, ph) {</span>
<span class="fc" id="L380">                                    private final int myLine = cLine;</span>
<span class="fc" id="L381">                                    private final String loc = location;</span>

                                    @Override
                                    public String toString() {
<span class="nc" id="L385">                                        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L386">                                        sb.append(&quot;Rule&quot;);</span>
<span class="nc" id="L387">                                        sb.append(&quot;{line=&quot;).append(myLine);</span>
<span class="nc" id="L388">                                        sb.append(&quot;, loc='&quot;).append(loc).append('\'');</span>
<span class="nc" id="L389">                                        sb.append('}');</span>
<span class="nc" id="L390">                                        return sb.toString();</span>
                                    }
                                };
<span class="fc" id="L393">                                lines.add(r);</span>
<span class="nc" id="L394">                            } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L395">                                throw new IllegalStateException(&quot;Problem parsing line '&quot; + currentLine + &quot;' in &quot; +</span>
                                                                location, e);
<span class="fc" id="L397">                            }</span>
                        }
                    }
                }
            }
<span class="fc" id="L402">        }</span>

<span class="fc" id="L404">        return lines;</span>
    }

    /**
     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.
     *
     * @param regex
     *            the regular expression to compile
     * @return an RPattern that will match this regex
     */
    private static RPattern pattern(final String regex) {
<span class="fc" id="L415">        final boolean startsWith = regex.startsWith(&quot;^&quot;);</span>
<span class="fc" id="L416">        final boolean endsWith = regex.endsWith(&quot;$&quot;);</span>
<span class="fc bfc" id="L417" title="All 4 branches covered.">        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());</span>
<span class="fc" id="L418">        final boolean boxes = content.contains(&quot;[&quot;);</span>

<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (!boxes) {</span>
<span class="fc bfc" id="L421" title="All 4 branches covered.">            if (startsWith &amp;&amp; endsWith) {</span>
                // exact match
<span class="fc bfc" id="L423" title="All 2 branches covered.">                if (content.length() == 0) {</span>
                    // empty
<span class="fc" id="L425">                    return new RPattern() {</span>
                        @Override
                        public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">                            return input.length() == 0;</span>
                        }
                    };
                } else {
<span class="fc" id="L432">                    return new RPattern() {</span>
                        @Override
                        public boolean isMatch(final CharSequence input) {
<span class="fc" id="L435">                            return input.equals(content);</span>
                        }
                    };
                }
<span class="pc bpc" id="L439" title="1 of 6 branches missed.">            } else if ((startsWith || endsWith) &amp;&amp; content.length() == 0) {</span>
                // matches every string
<span class="fc" id="L441">                return ALL_STRINGS_RMATCHER;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            } else if (startsWith) {</span>
                // matches from start
<span class="fc" id="L444">                return new RPattern() {</span>
                    @Override
                    public boolean isMatch(final CharSequence input) {
<span class="fc" id="L447">                        return startsWith(input, content);</span>
                    }
                };
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            } else if (endsWith) {</span>
                // matches from start
<span class="fc" id="L452">                return new RPattern() {</span>
                    @Override
                    public boolean isMatch(final CharSequence input) {
<span class="fc" id="L455">                        return endsWith(input, content);</span>
                    }
                };
            }
        } else {
<span class="fc" id="L460">            final boolean startsWithBox = content.startsWith(&quot;[&quot;);</span>
<span class="fc" id="L461">            final boolean endsWithBox = content.endsWith(&quot;]&quot;);</span>

<span class="fc bfc" id="L463" title="All 4 branches covered.">            if (startsWithBox &amp;&amp; endsWithBox) {</span>
<span class="fc" id="L464">                String boxContent = content.substring(1, content.length() - 1);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">                if (!boxContent.contains(&quot;[&quot;)) {</span>
                    // box containing alternatives
<span class="fc" id="L467">                    final boolean negate = boxContent.startsWith(&quot;^&quot;);</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                    if (negate) {</span>
<span class="fc" id="L469">                        boxContent = boxContent.substring(1);</span>
                    }
<span class="fc" id="L471">                    final String bContent = boxContent;</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    final boolean shouldMatch = !negate;</span>

<span class="fc bfc" id="L474" title="All 4 branches covered.">                    if (startsWith &amp;&amp; endsWith) {</span>
                        // exact match
<span class="fc" id="L476">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L479" title="All 4 branches covered.">                                return input.length() == 1 &amp;&amp; contains(bContent, input.charAt(0)) == shouldMatch;</span>
                            }
                        };
<span class="fc bfc" id="L482" title="All 2 branches covered.">                    } else if (startsWith) {</span>
                        // first char
<span class="fc" id="L484">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L487" title="All 4 branches covered.">                                return input.length() &gt; 0 &amp;&amp; contains(bContent, input.charAt(0)) == shouldMatch;</span>
                            }
                        };
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                    } else if (endsWith) {</span>
                        // last char
<span class="fc" id="L492">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L495" title="All 2 branches covered.">                                return input.length() &gt; 0 &amp;&amp;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;</span>
                            }
                        };
                    }
                }
            }
        }

<span class="fc" id="L504">        return new RPattern() {</span>
<span class="fc" id="L505">            Pattern pattern = Pattern.compile(regex);</span>

            @Override
            public boolean isMatch(final CharSequence input) {
<span class="fc" id="L509">                final Matcher matcher = pattern.matcher(input);</span>
<span class="fc" id="L510">                return matcher.find();</span>
            }
        };
    }

    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (prefix.length() &gt; input.length()) {</span>
<span class="fc" id="L517">            return false;</span>
        }
<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (int i = 0; i &lt; prefix.length(); i++) {</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (input.charAt(i) != prefix.charAt(i)) {</span>
<span class="fc" id="L521">                return false;</span>
            }
        }
<span class="fc" id="L524">        return true;</span>
    }

    private static String stripQuotes(String str) {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (str.startsWith(DOUBLE_QUOTE)) {</span>
<span class="fc" id="L529">            str = str.substring(1);</span>
        }

<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (str.endsWith(DOUBLE_QUOTE)) {</span>
<span class="fc" id="L533">            str = str.substring(0, str.length() - 1);</span>
        }

<span class="fc" id="L536">        return str;</span>
    }

    private final RPattern lContext;

    private final String pattern;

    private final PhonemeExpr phoneme;

    private final RPattern rContext;

    /**
     * Creates a new rule.
     *
     * @param pattern
     *            the pattern
     * @param lContext
     *            the left context
     * @param rContext
     *            the right context
     * @param phoneme
     *            the resulting phoneme
     */
<span class="fc" id="L559">    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {</span>
<span class="fc" id="L560">        this.pattern = pattern;</span>
<span class="fc" id="L561">        this.lContext = pattern(lContext + &quot;$&quot;);</span>
<span class="fc" id="L562">        this.rContext = pattern(&quot;^&quot; + rContext);</span>
<span class="fc" id="L563">        this.phoneme = phoneme;</span>
<span class="fc" id="L564">    }</span>

    /**
     * Gets the left context. This is a regular expression that must match to the left of the pattern.
     *
     * @return the left context Pattern
     */
    public RPattern getLContext() {
<span class="nc" id="L572">        return this.lContext;</span>
    }

    /**
     * Gets the pattern. This is a string-literal that must exactly match.
     *
     * @return the pattern
     */
    public String getPattern() {
<span class="fc" id="L581">        return this.pattern;</span>
    }

    /**
     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.
     *
     * @return the phoneme
     */
    public PhonemeExpr getPhoneme() {
<span class="fc" id="L590">        return this.phoneme;</span>
    }

    /**
     * Gets the right context. This is a regular expression that must match to the right of the pattern.
     *
     * @return the right context Pattern
     */
    public RPattern getRContext() {
<span class="nc" id="L599">        return this.rContext;</span>
    }

    /**
     * Decides if the pattern and context match the input starting at a position. It is a match if the
     * &lt;code&gt;lContext&lt;/code&gt; matches &lt;code&gt;input&lt;/code&gt; up to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; matches at i and
     * &lt;code&gt;rContext&lt;/code&gt; matches from the end of the match of &lt;code&gt;pattern&lt;/code&gt; to the end of &lt;code&gt;input&lt;/code&gt;.
     *
     * @param input
     *            the input String
     * @param i
     *            the int position within the input
     * @return true if the pattern and left/right context match, false otherwise
     */
    public boolean patternAndContextMatches(final CharSequence input, final int i) {
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L615">            throw new IndexOutOfBoundsException(&quot;Can not match pattern at negative indexes&quot;);</span>
        }

<span class="fc" id="L618">        final int patternLength = this.pattern.length();</span>
<span class="fc" id="L619">        final int ipl = i + patternLength;</span>

<span class="fc bfc" id="L621" title="All 2 branches covered.">        if (ipl &gt; input.length()) {</span>
            // not enough room for the pattern to match
<span class="fc" id="L623">            return false;</span>
        }

        // evaluate the pattern, left context and right context
        // fail early if any of the evaluations is not successful
<span class="fc bfc" id="L628" title="All 2 branches covered.">        if (!input.subSequence(i, ipl).equals(this.pattern)) {</span>
<span class="fc" id="L629">            return false;</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {</span>
<span class="fc" id="L631">            return false;</span>
        }
<span class="fc" id="L633">        return this.lContext.isMatch(input.subSequence(0, i));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>